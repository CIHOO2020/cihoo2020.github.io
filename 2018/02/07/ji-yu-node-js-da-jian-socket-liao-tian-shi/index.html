<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="海哥轻唱"><title>基于Node.js搭建Socket聊天室 · IVMA</title><meta name="description" content="前言可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多

前言可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多依靠传统"><meta name="keywords" content="海歌轻唱 爱吗"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">IVMA</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/CIHOO2020"><i class="fa fa-github"></i></a></li><li><a href="mailto:CIHOO@CIHOO.ME"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> 海哥轻唱</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>基于Node.js搭建Socket聊天室</a></h3></div><div class="post-content"><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#%E5%89%8D%E8%A8%80" title="前言"></a>前言</h5><p>可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多</p>
<!-- more -->
<h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a><a href="#%E5%89%8D%E8%A8%80" title="前言"></a>前言</h5><p>可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多依靠传统服务器端编程语言才能实现的事，甚至更加简便、更加高效。<br>本案例使用Node.js的net模块，建立服务端与客户端的Socket连接，简单实现了客户端广播消息通信和点对点通信。</p>
<h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" title="项目结构"></a>项目结构</h5><h6 id="server-js-服务端"><a href="#server-js-服务端" class="headerlink" title="server.js 服务端"></a><a href="#server-js-%E6%9C%8D%E5%8A%A1%E7%AB%AF" title="server.js 服务端"></a>server.js 服务端</h6><p>项目下的server.js是服务端的执行文件，用于创建服务端的Socket服务，监听指定端口；接收客户端传过来的数据，解析数据并按照数据中附带的协议进行广播消息通信或点对点通信。<br><strong>具体代码如下：</strong></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127  </p>
<p>// Socket聊天室 - server 服务端<br>const net = require(‘net’);  </p>
<p>// 定义clients（键值对集合），用于存储所有的客户端连接，通过用户名去索引客户端socket<br>let clients = {};  </p>
<p>let server = net.createServer((socket) =&gt; {  </p>
<p> // 客户端登入<br> function signin(clientDataContent) {<br> clientDataContent = JSON.parse(clientDataContent);<br> let username = clientDataContent.from;  </p>
<p> // 如果clients（客户端 socket 集合）中有1个以上的成员，就广播通知所有人谁谁上线了，除了他本身<br> if (Object.keys(clients).length) {<br> let onlineNotice = {  // 组成上线通知消息数据格式<br> protocol: ‘online’,<br> online: username,<br> onlineCount: Object.keys(clients).length + 1<br> };<br> // 遍历 clients ，给除了自身的所有客户端发送消息<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let noticeClient = clients[username];<br> noticeClient.write(JSON.stringify(onlineNotice));<br> }<br> }<br> }  </p>
<p> // 将新连接的客户端socket存储于clients<br> clients[username] = socket;  </p>
<p> // 服务端打印上线提示消息<br> console.log(`欢迎 ${socket.remoteAddress}:${socket.remotePort}【${username}】，加入聊天室，当前在线：${Object.keys(clients).length}`);<br> }  </p>
<p> // 广播消息通信<br> function broadcast(clientDataContent) {<br> // 广播出去消息数据格式 json<br> let sendClientData = JSON.parse(clientDataContent);  </p>
<p> // 遍历clients对象（for in），给所有的客户端socket广播消息<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let client = clients[username];<br> client.write(JSON.stringify(sendClientData));<br> }<br> }<br> }  </p>
<p> // p2p 点对点通信<br> function p2p(clientDataContent) {<br> let p2pClientData = JSON.parse(clientDataContent);<br> // 给指定的客户端发送消息<br> clients[p2pClientData.to].write(JSON.stringify(p2pClientData));<br> }  </p>
<p> // 给每一个连接服务端的客户端socket注册data事件<br> socket.on(‘data’, (chunk) =&gt; {<br> try {<br> // 对客户端传过来的数据chunk（json数据）进行序列化<br> let clientDataContent = chunk.toString().trim();  </p>
<p> // 获取协议<br> let protocol = JSON.parse(clientDataContent).protocol;<br> switch (protocol) {<br> case ‘signin’:<br> signin(clientDataContent);<br> break;<br> case ‘broadcast’:<br> broadcast(clientDataContent);<br> break;<br> case ‘p2p’:<br> p2p(clientDataContent);<br> break;<br> default:<br> socket.write(‘错误！未能识别的通信协议！’);<br> break;<br> }<br> } catch (error) {<br> socket.write(‘出现错误了哦~’);<br> throw error;<br> }<br> });  </p>
<p> // 给每一个连接服务端的客户端socket注册error事件，如果连接中断，则触发此事件<br> socket.on(‘error’, (error) =&gt; {<br> // 在客户端对象中，将连接中断的那个客户端删除<br> let deletekey = null;  </p>
<p> // 遍历clients对象，找到下线的socket，并将其删除<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let client = clients[username];<br> if (socket === client) deletekey = username;<br> }<br> }<br> delete clients[deletekey];  </p>
<p> // 广播通知所有人，谁谁下线了<br> let offlineNotice = {  // 组成下线通知消息数据格式<br> protocol: ‘offline’,<br> offline: deletekey,<br> onlineCount: Object.keys(clients).length<br> };<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let noticeClient = clients[username];<br> noticeClient.write(JSON.stringify(offlineNotice));<br> }<br> }  </p>
<p> // server 消息<br> console.log(`${deletekey} 下线了，当前在线：${Object.keys(clients).length}`);<br> });<br>});  </p>
<p>// 监听指定端口<br>let port = 2018;<br>server.listen(port, (error) =&gt; {<br> if (error) {<br> console.log(`${port}端口被占用！`);<br> } else {<br> console.log(`服务器端正常启动，正在监听${port}端口`);<br> }<br>});  </p>
<h6 id="client-js-客户端"><a href="#client-js-客户端" class="headerlink" title="client.js 客户端"></a><a href="#client-js-%E5%AE%A2%E6%88%B7%E7%AB%AF" title="client.js 客户端"></a>client.js 客户端</h6><p>项目下的client.js是客户端的执行文件，用于创建客户端的Socket服务。将用户输入的内容按特定的格式组成数据结构发给服务端，同时打印出服务端指定的内容。<br><strong>具体代码如下：</strong></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98  </p>
<p>// Socket聊天室 - 客户端 client<br>const net = require(‘net’);<br>const readline = require(‘readline’);<br>const rl = readline.createInterface(process.stdin, process.stdout);  </p>
<p>rl.question(‘请输入聊天昵称：’, (nickname) =&gt; {<br> nickname = nickname.trim();<br> if (!nickname) {<br> throw new Error(‘昵称不能为空！’);<br> }  </p>
<p> // 创建与服务端的连接<br> // 设置正确的服务端的ip地址和端口<br> let server = net.connect({port: 2018, host: ‘127.0.0.1’}, () =&gt; {  </p>
<p> // 登入操作<br> let user = {<br> protocol: ‘signin’,<br> from: nickname<br> };  </p>
<p> // 往服务端传送数据<br> server.write(JSON.stringify(user));<br> console.log(`【系统通知】已成功加入聊天室，尽情畅聊吧~`);  </p>
<p> // 监听服务端发送过来的数据<br> server.on(‘data’, (chunk) =&gt; {<br> try {<br> let serverDataContent = JSON.parse(chunk.toString().trim());<br> let protocol = serverDataContent.protocol;<br> switch (protocol) {<br> case ‘online’:<br> console.log(`\n【系统通知】欢迎：${serverDataContent.online}，加入聊天室，当前在线人数：${serverDataContent.onlineCount}\n`);<br> rl.prompt();<br> break;<br> case ‘offline’:<br> console.log(`\n【系统通知】${serverDataContent.offline}下线了，当前在线人数：${serverDataContent.onlineCount}\n`);<br> rl.prompt();<br> break;<br> case ‘broadcast’:<br> console.log(`\n[@所有人] ${serverDataContent.from}&gt; ${serverDataContent.message}\n`);<br> rl.prompt();<br> break;<br> case ‘p2p’:<br> console.log(`\n[@${serverDataContent.to}] ${serverDataContent.from}&gt; ${serverDataContent.message}\n`);<br> rl.prompt();<br> break;<br> default:<br> server.write(‘错误！未能识别的通信协议！’);<br> break;<br> }<br> } catch (error) {<br> server.write(‘出现错误了哦~’);<br> throw error;<br> }  </p>
<p> });  </p>
<p> rl.setPrompt(nickname + ‘&gt; ‘);  // 此时没有写入控制台<br> rl.prompt(); // 写入控制台  </p>
<p> // 输入一行内容敲回车<br> rl.on(‘line’, (line) =&gt; {<br> line = line.toString().trim();  </p>
<p> // 内容： user1:我只跟你说话  表示，客户端用户只跟user1通信<br> // 根据客户端用户输入的内容按“:”分割成两部分<br> let arrString = line.split(‘:’);<br> let sendServerData = null;  </p>
<p> // 组成往服务端发送的数据格式<br> if (arrString.length === 2) {<br> // 点对点<br> sendServerData = {<br> protocol: ‘p2p’,<br> from: nickname,<br> to: arrString[0],<br> message: arrString[1]<br> };<br> } else {<br> // 广播消息<br> sendServerData = {<br> protocol: ‘broadcast’,<br> from: nickname,<br> message: line<br> };<br> }  </p>
<p> // 往服务端发送数据<br> server.write(JSON.stringify(sendServerData));<br> rl.prompt(); // 写入控制台<br> });  </p>
<p> rl.on(‘close’, () =&gt; {  </p>
<p> });<br> });<br>});  </p>
<h5 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a><a href="#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD" title="实现功能"></a>实现功能</h5><p>目前已实现：客户端广播消息通信、点对点通信。</p>
<h5 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a><a href="#%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8" title="项目使用"></a>项目使用</h5><ol>
<li>启动服务端，<code>$ node server.js</code><br><img src="https://user-images.githubusercontent.com/24516169/36706538-325fc724-1ba5-11e8-8596-08b28f52ecc2.jpg" alt="启动服务端"></li>
<li>启动第一个客户端，<code>$ node client.js</code><br><img src="https://user-images.githubusercontent.com/24516169/36706534-27154c7c-1ba5-11e8-8c36-f0478296563d.jpg" alt="启动客户端"></li>
<li>启动第二个客户端，<code>$ node client.js</code></li>
<li>……</li>
</ol>
<h5 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a><a href="#%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91" title="演示视频"></a>演示视频</h5><p><img src="https://user-images.githubusercontent.com/24516169/36706486-f24b8e48-1ba4-11e8-8627-f236d924330d.gif" alt="Demo演示gif"></p>
<h5 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD" title="项目下载"></a>项目下载</h5><p>本案例源代码托管于GitHub，下载：<a target="_blank" rel="noopener" href="https://github.com/XPoet/node.js-chartroom">传送门</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端/" title="前端">前端 </a><a class="tag" href="/tags/Node-js/" title="Node.js">Node.js </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://ivma.me/2018/02/07/ji-yu-node-js-da-jian-socket-liao-tian-shi/,IVMA,基于Node.js搭建Socket聊天室,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/03/20/bu-xiu-de-shi-mian/" title="不朽的失眠">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/02/02/css-yuan-su-chui-zhi-ju-zhong-de-ji-chong-chang-yong-fang-fa/" title="CSS 元素垂直居中的几种常用方法">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:true|| false, 
  app_id:'OoFJYn1HFSt0jts0o0HbVrp0-9Nh9j0Va',
  app_key:'guQCdpN0EcWaGWA4110951ht',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>