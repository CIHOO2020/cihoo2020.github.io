<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="海哥轻唱"><title>JavaScript 数据结构与算法（四）队列结构 · IVMA</title><meta name="description" content="认识队列队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)

认识队列队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)
受限之处：

只允许在表的前端（front）进行删除操作。
在"><meta name="keywords" content="海歌轻唱 爱吗"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">IVMA</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/CIHOO2020"><i class="fa fa-github"></i></a></li><li><a href="mailto:CIHOO@CIHOO.ME"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> 海哥轻唱</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JavaScript 数据结构与算法（四）队列结构</a></h3></div><div class="post-content"><h3 id="认识队列"><a href="#认识队列" class="headerlink" title="认识队列"></a><a href="#%E8%AE%A4%E8%AF%86%E9%98%9F%E5%88%97" title="认识队列"></a>认识队列</h3><p>队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)</p>
<!-- more -->
<h3 id="认识队列-1"><a href="#认识队列-1" class="headerlink" title="认识队列"></a><a href="#%E8%AE%A4%E8%AF%86%E9%98%9F%E5%88%97" title="认识队列"></a>认识队列</h3><p>队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)</p>
<p><strong>受限之处：</strong></p>
<ul>
<li>只允许在表的前端（front）进行删除操作。</li>
<li>在表的后端（rear）进行插入操作。</li>
</ul>
<p>生活中类似队列结构的场景：</p>
<ul>
<li>排队,，比如在电影院，商场，甚至是厕所排队。</li>
<li>优先排队的人，优先处理。 (买票、结账、WC)。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/24516169/88038526-e9f6c880-cb78-11ea-859d-1faaaebed3bf.png" alt="queue"></p>
<h4 id="队列图解"><a href="#队列图解" class="headerlink" title="队列图解"></a><a href="#%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A3" title="队列图解"></a>队列图解</h4><p><img src="https://user-images.githubusercontent.com/24516169/88038782-45c15180-cb79-11ea-8439-bdc7e240d10d.png" alt="queue"></p>
<h4 id="队列在程序中的应用"><a href="#队列在程序中的应用" class="headerlink" title="队列在程序中的应用"></a><a href="#%E9%98%9F%E5%88%97%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" title="队列在程序中的应用"></a>队列在程序中的应用</h4><ul>
<li>打印队列：计算机打印多个文件的时候，需要排队打印。</li>
<li>线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。</li>
</ul>
<h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" title="队列的实现"></a>队列的实现</h3><p>队列的实现和栈一样，有两种方案：</p>
<ul>
<li>基于数组实现。</li>
<li>基于链表实现。</li>
</ul>
<h4 id="队列常见的操作"><a href="#队列常见的操作" class="headerlink" title="队列常见的操作"></a><a href="#%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C" title="队列常见的操作"></a>队列常见的操作</h4><ul>
<li><code>enqueue(element)</code>：向队列尾部添加一个（或多个）新的项。</li>
<li><code>dequeue()</code>：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li>
<li><code>front()</code>：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Stack 类的 peek 方法非常类似）。</li>
<li><code>isEmpty()</code>：如果队列中不包含任何元素，返回 true，否则返回 false。</li>
<li><code>size()</code>：返回队列包含的元素个数，与数组的 length 属性类似。</li>
<li><code>toString()</code>：将队列中的内容，转成字符串形式。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" title="代码实现"></a>代码实现</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37  </p>
<p>// 使用 ES6 实现<br>class Queue {<br> items = [];  </p>
<p> // enqueue() 入队，将元素加入到队列中<br> enqueue(item) {<br> this.items.push(item);<br> }  </p>
<p> // dequeue() 出队，从队列中删除前端元素，返回删除的元素<br> dequeue() {<br> return this.items.shift();<br> }  </p>
<p> // front() 查看队列的前端元素<br> front() {<br> return this.items[0];<br> }  </p>
<p> // isEmpty() 查看队列是否为空<br> isEmpty() {<br> return this.items.length === 0;<br> }  </p>
<p> // size() 查看队列中元素的个数<br> size() {<br> return this.items.length;<br> }  </p>
<p> toString() {<br> let result = “”;<br> for (let item of this.items) {<br> result += item + “ “;<br> }<br> return result;<br> }<br>}  </p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" title="测试代码"></a>测试代码</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p>
<p>const queue = new Queue();  </p>
<p>// 入队操作<br>queue.enqueue(“a”);<br>queue.enqueue(“b”);<br>queue.enqueue(“c”);<br>queue.enqueue(“d”);<br>console.log(queue.items); //–&gt; [“a”, “b”, “c”, “d”]  </p>
<p>// 出队操作（先进先出）<br>queue.dequeue();<br>queue.dequeue();<br>console.log(queue.items); //–&gt; [“c”, “d”]  </p>
<p>// 查看队头的元素<br>console.log(queue.front()); //–&gt; c  </p>
<p>console.log(queue.isEmpty()); //–&gt; false<br>console.log(queue.size()); //–&gt; 2<br>console.log(queue.toString()); //–&gt; c d  </p>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8" title="队列的应用"></a>队列的应用</h3><p>使用队列实现小游戏：<strong>击鼓传花</strong>。</p>
<p>分析：传入一组数据集合和设定的数字 number，循环遍历数组内元素，遍历到的元素为指定数字 number 时将该元素删除，直至数组剩下一个元素。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1" title="代码实现"></a>代码实现</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33  </p>
<p>function passGame(nameList, number) {<br> // 1、new 一个 Queue 对象<br> const queue = new Queue();  </p>
<p> // 2、将 nameList 里面的每一个元素入队<br> for (const name of nameList) {<br> queue.enqueue(name);<br> }  </p>
<p> // 3、开始数数<br> // 队列中只剩下 1 个元素时就停止数数<br> while (queue.size() &gt; 1) {<br> // 不是 number 时，重新加入到队尾<br> // 是 number 时，将其删除  </p>
<p> for (let i = 0; i &lt; number - 1; i++) {<br> // number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中）<br> queue.enqueue(queue.dequeue());<br> }  </p>
<p> // number 对应这个人，直接从队列中删除<br> // 由于队列没有像数组一样的下标值不能直接取到某一元素，<br> // 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾，<br> // 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除<br> queue.dequeue();<br> }  </p>
<p> // 4、获取最后剩下的那个人<br> const endName = queue.front();  </p>
<p> // 5、返回这个人在原数组中对应的索引<br> return nameList.indexOf(endName);<br>}  </p>
<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-1" title="测试代码"></a>测试代码</h4><p>1<br>2<br>3  </p>
<p>const names = [“lily”, “lucy”, “tom”, “tony”, “jack”];<br>const targetIndex = passGame(names, 4);<br>console.log(“击鼓传花”, names[targetIndex]); //–&gt; lily  </p>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a><a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97" title="优先队列"></a>优先队列</h3><p>优先级队列主要考虑的问题：</p>
<ul>
<li>每个元素不再只是一个数据，还包含数据的优先级。</li>
<li>在添加数据过程中，根据优先级放入到正确位置。</li>
</ul>
<h4 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a><a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" title="优先队列的实现"></a>优先队列的实现</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2" title="代码实现"></a>代码实现</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69  </p>
<p>class PriorityQueue {<br> items = [];  </p>
<p> // 内部类<br> QueueElement = class {<br> constructor(element, priority) {<br> this.element = element;<br> this.priority = priority;<br> }<br> };  </p>
<p> // enqueue() 入队，将元素按优先级加入到队列中<br> enqueue(element, priority) {<br> // 根据传入的元素，创建 QueueElement 对象<br> const queueElement = new this.QueueElement(element, priority);  </p>
<p> // 判断队列是否为空<br> if (this.isEmpty()) {<br> // 如果为空，不用判断优先级，直接添加<br> this.items.push(queueElement);<br> } else {<br> // 定义一个变量记录是否成功添加了新元素<br> let added = false;  </p>
<p> for (let i = 0; i &lt; this.items.length; i++) {<br> // 让新插入的元素进行优先级比较，priority 值越小，优先级越大<br> if (queueElement.priority &lt; this.items[i].priority) {<br> // 在指定的位置插入元素<br> this.items.splice(i, 0, queueElement);<br> added = true;<br> break;<br> }<br> }  </p>
<p> // 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后<br> if (!added) {<br> this.items.push(queueElement);<br> }<br> }<br> }  </p>
<p> // dequeue() 出队，从队列中删除前端元素，返回删除的元素<br> dequeue() {<br> return this.items.shift();<br> }  </p>
<p> // front() 查看队列的前端元素<br> front() {<br> return this.items[0];<br> }  </p>
<p> // isEmpty() 查看队列是否为空<br> isEmpty() {<br> return this.items.length === 0;<br> }  </p>
<p> // size() 查看队列中元素的个数<br> size() {<br> return this.items.length;<br> }  </p>
<p> toString() {<br> let result = “”;<br> for (let item of this.items) {<br> result += item.element + “-“ + item.priority + “ “;<br> }<br> return result;<br> }<br>}  </p>
<h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-2" title="测试代码"></a>测试代码</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29  </p>
<p>const priorityQueue = new PriorityQueue();  </p>
<p>// 入队<br>priorityQueue.enqueue(“A”, 10);<br>priorityQueue.enqueue(“B”, 15);<br>priorityQueue.enqueue(“C”, 11);<br>priorityQueue.enqueue(“D”, 20);<br>priorityQueue.enqueue(“E”, 18);  </p>
<p>console.log(priorityQueue.items);<br>//–&gt; output:<br>// QueueElement {element: “A”, priority: 10}<br>// QueueElement {element: “C”, priority: 11}<br>// QueueElement {element: “B”, priority: 15}<br>// QueueElement {element: “E”, priority: 18}<br>// QueueElement {element: “D”, priority: 20}  </p>
<p>// 出队<br>priorityQueue.dequeue();<br>priorityQueue.dequeue();<br>console.log(priorityQueue.items);<br>//–&gt; output:<br>// QueueElement {element: “B”, priority: 15}<br>// QueueElement {element: “E”, priority: 18}<br>// QueueElement {element: “D”, priority: 20}  </p>
<p>console.log(priorityQueue.isEmpty()); //–&gt; false<br>console.log(priorityQueue.size()); //–&gt; 3<br>console.log(priorityQueue.toString()); //–&gt; B-15 E-18 D-20  </p>
<h3 id="数组、栈和队列图解"><a href="#数组、栈和队列图解" class="headerlink" title="数组、栈和队列图解"></a><a href="#%E6%95%B0%E7%BB%84%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A3" title="数组、栈和队列图解"></a>数组、栈和队列图解</h3><p><img src="https://user-images.githubusercontent.com/24516169/88051118-b02ebd80-cb8a-11ea-9acf-4329cbbff6fc.png" alt="array-stack-queue"></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-07-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/算法专辑/" title="算法专辑">算法专辑 </a><a class="tag" href="/tags/数据结构/" title="数据结构">数据结构 </a><a class="tag" href="/tags/算法/" title="算法">算法 </a><a class="tag" href="/tags/队列/" title="队列">队列 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://ivma.me/2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-si-dui-lie-jie-gou/,IVMA,JavaScript 数据结构与算法（四）队列结构,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/07/23/javascript-shu-ju-jie-gou-yu-suan-fa-wu-dan-xiang-lian-biao-jie-gou/" title="JavaScript 数据结构与算法（五）单向链表结构">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-san-zhan-jie-gou/" title="JavaScript 数据结构与算法（三）栈结构">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:true|| false, 
  app_id:'OoFJYn1HFSt0jts0o0HbVrp0-9Nh9j0Va',
  app_key:'guQCdpN0EcWaGWA4110951ht',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>