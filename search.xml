<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript 数据结构与算法（五）单向链表结构</title>
      <link href="2020/07/23/javascript-shu-ju-jie-gou-yu-suan-fa-wu-dan-xiang-lian-biao-jie-gou/"/>
      <url>2020/07/23/javascript-shu-ju-jie-gou-yu-suan-fa-wu-dan-xiang-lian-biao-jie-gou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="认识链表"><a href="#认识链表" class="headerlink" title="认识链表"></a><a href="#%E8%AE%A4%E8%AF%86%E9%93%BE%E8%A1%A8" title="认识链表"></a>认识链表</h3><!-- more --><h3 id="认识链表-1"><a href="#认识链表-1" class="headerlink" title="认识链表"></a><a href="#%E8%AE%A4%E8%AF%86%E9%93%BE%E8%A1%A8" title="认识链表"></a>认识链表</h3><h4 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a><a href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84" title="链表和数组"></a>链表和数组</h4><p>链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。</p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="#%E6%95%B0%E7%BB%84" title="数组"></a>数组</h5><ul><li><p>存储多个元素，数组（或列表）可能是最常用的数据结构。</p></li><li><p>几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 <code>[]</code> 语法来访问数组元素。</p></li><li><p>数组缺点：</p><p>数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)</p><p>在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。</p></li></ul><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a><a href="#%E9%93%BE%E8%A1%A8" title="链表"></a>链表</h5><ul><li><p>存储多个元素，另外一个选择就是使用链表。</p></li><li><p>不同于数组，链表中的元素在内存中不必是连续的空间。</p></li><li><p>链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成。</p></li><li><p>链表优点：</p><p>内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。</p><p>链表不必在创建时就确定大小，并且大小可以无限延伸下去。</p><p>链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。</p></li><li><p>链表缺点：</p><p>访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)</p><p>无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。</p><p>虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。</p></li></ul><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a><a href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8" title="单向链表"></a>单向链表</h3><p>单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。</p><ul><li><p>链表的火车结构</p><p><img src="https://user-images.githubusercontent.com/24516169/88268829-a1b8e100-cd05-11ea-91d9-1c4322783a3d.png" alt="链表的火车结构"></p></li><li><p>链表的数据结构</p><p>head 属性指向链表的第一个节点。<br>链表中的最后一个节点指向 null。<br>当链表中一个节点也没有的时候，head 直接指向 null。</p><p><img src="https://user-images.githubusercontent.com/24516169/88271130-50aaec00-cd09-11ea-8910-eaf4f4509c6d.png" alt="链表的数据结构"></p></li><li><p>给火车加上数据后的结构</p><p><img src="https://user-images.githubusercontent.com/24516169/88268878-b09f9380-cd05-11ea-9fc7-f2e96fe8c764.png" alt="给火车加上数据后的结构"></p></li></ul><h4 id="链表中的常见操作"><a href="#链表中的常见操作" class="headerlink" title="链表中的常见操作"></a><a href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" title="链表中的常见操作"></a>链表中的常见操作</h4><ul><li><code>append(element)</code> 向链表尾部添加一个新的项。</li><li><code>insert(position, element)</code> 向链表的特定位置插入一个新的项。</li><li><code>get(position)</code> 获取对应位置的元素。</li><li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回-1。</li><li><code>update(position, element)</code> 修改某个位置的元素。</li><li><code>removeAt(position)</code> 从链表的特定位置移除一项。</li><li><code>remove(element)</code> 从链表中移除一项。</li><li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li><li><code>size()</code> 返回链表包含的元素个数，与数组的 length 属性类似。</li><li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li></ul><h4 id="单向链表的封装"><a href="#单向链表的封装" class="headerlink" title="单向链表的封装"></a><a href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%81%E8%A3%85" title="单向链表的封装"></a>单向链表的封装</h4><h5 id="创建单向链表类"><a href="#创建单向链表类" class="headerlink" title="创建单向链表类"></a><a href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%B1%BB" title="创建单向链表类"></a>创建单向链表类</h5><p>先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16  </p><p>class LinkedList {<br> // 初始链表长度为 0<br> length = 0;  </p><p> // 初始 head 为 null，head 指向链表的第一个节点<br> head = null;  </p><p> // 内部类（链表里的节点 Node）<br> Node = class {<br> data;<br> next = null;<br> constructor(data) {<br> this.data = data;<br> }<br> };<br>}  </p><h5 id="实现-append-方法"><a href="#实现-append-方法" class="headerlink" title="实现 append() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-append-%E6%96%B9%E6%B3%95" title="实现 append() 方法"></a>实现 append() 方法</h5><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30  </p><p>// append() 往链表尾部追加数据<br>append(data) {  </p><p> // 1、创建新节点<br> const newNode = new this.Node(data);  </p><p> // 2、追加新节点<br> if (this.length === 0) {  </p><p> // 链表长度为 0 时，即只有 head 的时候<br> this.head = newNode;  </p><p> } else {<br> // 链表长度大于 0 时，在最后面添加新节点<br> let currentNode = this.head;  </p><p> // 当 currentNode.next 不为空时，<br> // 循序依次找最后一个节点，即节点的 next 为 null 时<br> while (currentNode.next !== null) {<br> currentNode = currentNode.next;<br> }  </p><p> // 最后一个节点的 next 指向新节点<br> currentNode.next = newNode;<br> }  </p><p> // 3、追加完新节点后，链表长度 + 1<br> this.length++;  </p><p>}  </p><h6 id="过程图解"><a href="#过程图解" class="headerlink" title="过程图解"></a><a href="#%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3" title="过程图解"></a>过程图解</h6><ul><li><p>首先让 currentNode 指向第一个节点。</p><p><img src="https://user-images.githubusercontent.com/24516169/88273783-4854b000-cd0d-11ea-8840-176f2e8cc219.png"></p></li><li><p>通过 while 循环使 currentNode 指向最后一个节点，最后通过 currentNode.next = newNode，让最后一个节点指向新节点 newNode。</p><p><img src="https://user-images.githubusercontent.com/24516169/88273806-50aceb00-cd0d-11ea-95f7-c1583464e123.png"></p></li></ul><h6 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>const linkedList = new LinkedList();<br>// 测试 append 方法<br>linkedList.append(“A”);<br>linkedList.append(“B”);<br>linkedList.append(“C”);<br>console.log(linkedList);  </p><p><img src="https://user-images.githubusercontent.com/24516169/88274253-f9f3e100-cd0d-11ea-970d-e39e8e0f3caa.png"></p><h5 id="实现-toString-方法"><a href="#实现-toString-方法" class="headerlink" title="实现 toString() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-toString-%E6%96%B9%E6%B3%95" title="实现 toString() 方法"></a>实现 toString() 方法</h5><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12  </p><p>toString() {<br> let currentNode = this.head;<br> let result = ‘’;  </p><p> // 遍历所有的节点，拼接为字符串，直到节点为 null<br> while (currentNode) {<br> result += currentNode.data + ‘ ‘;<br> currentNode = currentNode.next;<br> }  </p><p> return result;<br>}  </p><h6 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-1" title="代码测试"></a>代码测试</h6><p>1<br>2  </p><p>// 测试 toString 方法<br>console.log(linkedList.toString()); //–&gt; AA BB CC  </p><h5 id="实现-insert-方法"><a href="#实现-insert-方法" class="headerlink" title="实现 insert() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-insert-%E6%96%B9%E6%B3%95" title="实现 insert() 方法"></a>实现 insert() 方法</h5><h6 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42  </p><p>// insert() 在指定位置（position）插入节点<br>insert(position, data) {<br> // position 新插入节点的位置<br> // position = 0 表示新插入后是第一个节点<br> // position = 1 表示新插入后是第二个节点，以此类推  </p><p> // 1、对 position 进行越界判断，不能小于 0 或大于链表长度<br> if (position &lt; 0 || position &gt; this.length) return false;  </p><p> // 2、创建新节点<br> const newNode = new this.Node(data);  </p><p> // 3、插入节点<br> if (position === 0) { // position = 0 的情况<br> // 让新节点的 next 指向 原来的第一个节点，即 head<br> newNode.next = this.head;  </p><p> // head 赋值为 newNode<br> this.head = newNode;<br> } else { // 0 &lt; position &lt;= length 的情况  </p><p> // 初始化一些变量<br> let currentNode = this.head; // 当前节点初始化为 head<br> let previousNode = null; // head 的 上一节点为 null<br> let index = 0; // head 的 index 为 0  </p><p> // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode<br> // 直到找到要插入的位置<br> while (index++ &lt; position) {<br> previousNode = currentNode;<br> currentNode = currentNode.next;<br> }  </p><p> // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向<br> newNode.next = currentNode;<br> previousNode.next = newNode;<br> }  </p><p> // 更新链表长度<br> this.length++;<br> return newNode;<br>}  </p><h6 id="代码测试-2"><a href="#代码测试-2" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-2" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3<br>4  </p><p>// 测试 insert 方法<br>linkedList.insert(0, “123”);<br>linkedList.insert(2, “456”);<br>console.log(linkedList.toString()); //–&gt; 123 AA 456 BB CC  </p><h5 id="实现-getData-方法"><a href="#实现-getData-方法" class="headerlink" title="实现 getData() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-getData-%E6%96%B9%E6%B3%95" title="实现 getData() 方法"></a>实现 getData() 方法</h5><p>获取指定位置（position）的 data。</p><h6 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14  </p><p>getData(position) {<br> // 1、position 越界判断<br> if (position &lt; 0 || position &gt;= this.length) return null;  </p><p> // 2、获取指定 position 节点的 data<br> let currentNode = this.head;<br> let index = 0;  </p><p> while (index++ &lt; position) {<br> currentNode = currentNode.next;<br> }<br> // 3、返回 data<br> return currentNode.data;<br>}  </p><h6 id="代码测试-3"><a href="#代码测试-3" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-3" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3  </p><p>// 测试 getData 方法<br>console.log(linkedList.getData(0)); //–&gt; 123<br>console.log(linkedList.getData(1)); //–&gt; AA  </p><h5 id="实现-indexOf-方法"><a href="#实现-indexOf-方法" class="headerlink" title="实现 indexOf() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-indexOf-%E6%96%B9%E6%B3%95" title="实现 indexOf() 方法"></a>实现 indexOf() 方法</h5><p>indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。</p><h6 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15  </p><p>indexOf(data) {  </p><p> let currentNode = this.head;<br> let index = 0;  </p><p> while (currentNode) {<br> if (currentNode.data === data) {<br> return index;<br> }<br> currentNode = currentNode.next;<br> index++;<br> }  </p><p> return -1;<br>}  </p><h6 id="代码测试-4"><a href="#代码测试-4" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-4" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3  </p><p>// 测试 indexOf 方法<br>console.log(linkedList.indexOf(“AA”)); //–&gt; 1<br>console.log(linkedList.indexOf(“ABC”)); //–&gt; -1  </p><h5 id="实现-update-方法"><a href="#实现-update-方法" class="headerlink" title="实现 update() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-update-%E6%96%B9%E6%B3%95" title="实现 update() 方法"></a>实现 update() 方法</h5><p>update(position, data) 修改指定位置节点的 data。</p><h6 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17  </p><p>update(position, data) {<br> // 涉及到 position 都要进行越界判断<br> // 1、position 越界判断<br> if (position &lt; 0 || position &gt;= this.length) return false;  </p><p> // 2、痛过循环遍历，找到指定 position 的节点<br> let currentNode = this.head;<br> let index = 0;<br> while (index++ &lt; position) {<br> currentNode = currentNode.next;<br> }  </p><p> // 3、修改节点 data<br> currentNode.data = data;  </p><p> return currentNode;<br>}  </p><h6 id="代码测试-5"><a href="#代码测试-5" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-5" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3<br>4<br>5  </p><p>// 测试 update 方法<br>linkedList.update(0, “12345”);<br>console.log(linkedList.toString()); //–&gt; 12345 AA 456 BB CC<br>linkedList.update(1, “54321”);<br>console.log(linkedList.toString()); //–&gt; 12345 54321 456 BB CC  </p><h5 id="实现-removeAt-方法"><a href="#实现-removeAt-方法" class="headerlink" title="实现 removeAt() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-removeAt-%E6%96%B9%E6%B3%95" title="实现 removeAt() 方法"></a>实现 removeAt() 方法</h5><p>removeAt(position) 删除指定位置的节点。</p><h6 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31  </p><p>removeAt(position) {<br> // 1、position 越界判断<br> if (position &lt; 0 || position &gt;= this.length) return null;  </p><p> // 2、删除指定 position 节点<br> let currentNode = this.head;<br> if (position === 0) {<br> // position = 0 的情况<br> this.head = this.head.next;  </p><p> } else {<br> // position &gt; 0 的情况<br> // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode  </p><p> let previousNode = null;<br> let index = 0;  </p><p> while (index++ &lt; position) {<br> previousNode = currentNode;<br> currentNode = currentNode.next;<br> }  </p><p> // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。<br> previousNode.next = currentNode.next;<br> }  </p><p> // 3、更新链表长度 -1<br> this.length–;  </p><p> return currentNode;<br>}  </p><h6 id="代码测试-6"><a href="#代码测试-6" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-6" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3  </p><p>// 测试 removeAt 方法<br>linkedList.removeAt(3);<br>console.log(linkedList.toString()); //–&gt; 12345 54321 456 CC  </p><h5 id="实现-remove-方法"><a href="#实现-remove-方法" class="headerlink" title="实现 remove() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-remove-%E6%96%B9%E6%B3%95" title="实现 remove() 方法"></a>实现 remove() 方法</h5><p>remove(data) 删除指定 data 所在的节点。</p><h6 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3  </p><p>remove(data) {<br> this.removeAt(this.indexOf(data));<br>}  </p><h6 id="代码测试-7"><a href="#代码测试-7" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-7" title="代码测试"></a>代码测试</h6><p>1<br>2<br>3  </p><p>// 测试 remove 方法<br>linkedList.remove(“CC”);<br>console.log(linkedList.toString()); //–&gt; 12345 54321 456  </p><h5 id="实现-isEmpty-方法"><a href="#实现-isEmpty-方法" class="headerlink" title="实现 isEmpty() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-isEmpty-%E6%96%B9%E6%B3%95" title="实现 isEmpty() 方法"></a>实现 isEmpty() 方法</h5><p>isEmpty() 判断链表是否为空。</p><h6 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3  </p><p>isEmpty() {<br> return this.length === 0;<br>}  </p><h6 id="代码测试-8"><a href="#代码测试-8" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-8" title="代码测试"></a>代码测试</h6><p>1<br>2  </p><p>// 测试 isEmpty 方法<br>console.log(linkedList.isEmpty()); //–&gt; false  </p><h5 id="实现-size-方法"><a href="#实现-size-方法" class="headerlink" title="实现 size() 方法"></a><a href="#%E5%AE%9E%E7%8E%B0-size-%E6%96%B9%E6%B3%95" title="实现 size() 方法"></a>实现 size() 方法</h5><p>size() 获取链表的长度。</p><h6 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9" title="代码实现"></a>代码实现</h6><p>1<br>2<br>3  </p><p>size() {<br> return this.length;<br>}  </p><h6 id="代码测试-9"><a href="#代码测试-9" class="headerlink" title="代码测试"></a><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-9" title="代码测试"></a>代码测试</h6><p>1<br>2  </p><p>// 测试 size 方法<br>console.log(linkedList.size()); //–&gt; 3  </p><h5 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a><a href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0" title="完整实现"></a>完整实现</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204  </p><p>class LinkedList {<br> // 初始链表长度为 0<br> length = 0;  </p><p> // 初始 head 为 null，head 指向链表的第一个节点<br> head = null;  </p><p> // 内部类（链表里的节点 Node）<br> Node = class {<br> data;<br> next = null;  </p><p> constructor(data) {<br> this.data = data;<br> }<br> };  </p><p> // ———— 链表的常见操作 ———— //  </p><p> // append() 往链表尾部追加数据<br> append(data) {<br> // 1、创建新节点<br> const newNode = new this.Node(data);  </p><p> // 2、追加新节点<br> if (this.length === 0) {<br> // 链表长度为 0 时，即只有 head 的时候<br> this.head = newNode;<br> } else {<br> // 链表长度大于 0 时，在最后面添加新节点<br> let currentNode = this.head;  </p><p> // 当 currentNode.next 不为空时，<br> // 循序依次找最后一个节点，即节点的 next 为 null 时<br> while (currentNode.next !== null) {<br> currentNode = currentNode.next;<br> }  </p><p> // 最后一个节点的 next 指向新节点<br> currentNode.next = newNode;<br> }  </p><p> // 3、追加完新节点后，链表长度 + 1<br> this.length++;<br> }  </p><p> // insert() 在指定位置（position）插入节点<br> insert(position, data) {<br> // position 新插入节点的位置<br> // position = 0 表示新插入后是第一个节点<br> // position = 1 表示新插入后是第二个节点，以此类推  </p><p> // 1、对 position 进行越界判断，不能小于 0 或大于链表长度<br> if (position &lt; 0 || position &gt; this.length) return false;  </p><p> // 2、创建新节点<br> const newNode = new this.Node(data);  </p><p> // 3、插入节点<br> if (position === 0) {<br> // position = 0 的情况<br> // 让新节点的 next 指向 原来的第一个节点，即 head<br> newNode.next = this.head;  </p><p> // head 赋值为 newNode<br> this.head = newNode;<br> } else {<br> // 0 &lt; position &lt;= length 的情况  </p><p> // 初始化一些变量<br> let currentNode = this.head; // 当前节点初始化为 head<br> let previousNode = null; // head 的 上一节点为 null<br> let index = 0; // head 的 index 为 0  </p><p> // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode<br> // 直到找到要插入的位置<br> while (index++ &lt; position) {<br> previousNode = currentNode;<br> currentNode = currentNode.next;<br> }  </p><p> // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向<br> newNode.next = currentNode;<br> previousNode.next = newNode;<br> }  </p><p> // 更新链表长度<br> this.length++;<br> return newNode;<br> }  </p><p> // getData() 获取指定位置的 data<br> getData(position) {<br> // 1、position 越界判断<br> if (position &lt; 0 || position &gt;= this.length) return null;  </p><p> // 2、获取指定 position 节点的 data<br> let currentNode = this.head;<br> let index = 0;  </p><p> while (index++ &lt; position) {<br> currentNode = currentNode.next;<br> }  </p><p> // 3、返回 data<br> return currentNode.data;<br> }  </p><p> // indexOf() 返回指定 data 的 index，如果没有，返回 -1。<br> indexOf(data) {<br> let currentNode = this.head;<br> let index = 0;  </p><p> while (currentNode) {<br> if (currentNode.data === data) {<br> return index;<br> }<br> currentNode = currentNode.next;<br> index++;<br> }  </p><p> return -1;<br> }  </p><p> // update() 修改指定位置节点的 data<br> update(position, data) {<br> // 涉及到 position 都要进行越界判断<br> // 1、position 越界判断<br> if (position &lt; 0 || position &gt;= this.length) return false;  </p><p> // 2、痛过循环遍历，找到指定 position 的节点<br> let currentNode = this.head;<br> let index = 0;<br> while (index++ &lt; position) {<br> currentNode = currentNode.next;<br> }  </p><p> // 3、修改节点 data<br> currentNode.data = data;  </p><p> return currentNode;<br> }  </p><p> // removeAt() 删除指定位置的节点<br> removeAt(position) {<br> // 1、position 越界判断<br> if (position &lt; 0 || position &gt;= this.length) return null;  </p><p> // 2、删除指定 position 节点<br> let currentNode = this.head;<br> if (position === 0) {<br> // position = 0 的情况<br> this.head = this.head.next;<br> } else {<br> // position &gt; 0 的情况<br> // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode  </p><p> let previousNode = null;<br> let index = 0;  </p><p> while (index++ &lt; position) {<br> previousNode = currentNode;<br> currentNode = currentNode.next;<br> }  </p><p> // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。<br> previousNode.next = currentNode.next;<br> }  </p><p> // 3、更新链表长度 -1<br> this.length–;  </p><p> return currentNode;<br> }  </p><p> // remove() 删除指定 data 的节点<br> remove(data) {<br> this.removeAt(this.indexOf(data));<br> }  </p><p> // isEmpty() 判断链表是否为空<br> isEmpty() {<br> return this.length === 0;<br> }  </p><p> // size() 获取链表的长度<br> size() {<br> return this.length;<br> }  </p><p> // toString() 链表数据以字符串形式返回<br> toString() {<br> let currentNode = this.head;<br> let result = “”;  </p><p> // 遍历所有的节点，拼接为字符串，直到节点为 null<br> while (currentNode) {<br> result += currentNode.data + “ “;<br> currentNode = currentNode.next;<br> }  </p><p> return result;<br> }<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法专辑 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 单向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据结构与算法（四）队列结构</title>
      <link href="2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-si-dui-lie-jie-gou/"/>
      <url>2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-si-dui-lie-jie-gou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="认识队列"><a href="#认识队列" class="headerlink" title="认识队列"></a><a href="#%E8%AE%A4%E8%AF%86%E9%98%9F%E5%88%97" title="认识队列"></a>认识队列</h3><p>队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)</p><!-- more --><h3 id="认识队列-1"><a href="#认识队列-1" class="headerlink" title="认识队列"></a><a href="#%E8%AE%A4%E8%AF%86%E9%98%9F%E5%88%97" title="认识队列"></a>认识队列</h3><p>队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)</p><p><strong>受限之处：</strong></p><ul><li>只允许在表的前端（front）进行删除操作。</li><li>在表的后端（rear）进行插入操作。</li></ul><p>生活中类似队列结构的场景：</p><ul><li>排队,，比如在电影院，商场，甚至是厕所排队。</li><li>优先排队的人，优先处理。 (买票、结账、WC)。</li></ul><p><img src="https://user-images.githubusercontent.com/24516169/88038526-e9f6c880-cb78-11ea-859d-1faaaebed3bf.png" alt="queue"></p><h4 id="队列图解"><a href="#队列图解" class="headerlink" title="队列图解"></a><a href="#%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A3" title="队列图解"></a>队列图解</h4><p><img src="https://user-images.githubusercontent.com/24516169/88038782-45c15180-cb79-11ea-8439-bdc7e240d10d.png" alt="queue"></p><h4 id="队列在程序中的应用"><a href="#队列在程序中的应用" class="headerlink" title="队列在程序中的应用"></a><a href="#%E9%98%9F%E5%88%97%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" title="队列在程序中的应用"></a>队列在程序中的应用</h4><ul><li>打印队列：计算机打印多个文件的时候，需要排队打印。</li><li>线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。</li></ul><h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" title="队列的实现"></a>队列的实现</h3><p>队列的实现和栈一样，有两种方案：</p><ul><li>基于数组实现。</li><li>基于链表实现。</li></ul><h4 id="队列常见的操作"><a href="#队列常见的操作" class="headerlink" title="队列常见的操作"></a><a href="#%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C" title="队列常见的操作"></a>队列常见的操作</h4><ul><li><code>enqueue(element)</code>：向队列尾部添加一个（或多个）新的项。</li><li><code>dequeue()</code>：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li><li><code>front()</code>：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Stack 类的 peek 方法非常类似）。</li><li><code>isEmpty()</code>：如果队列中不包含任何元素，返回 true，否则返回 false。</li><li><code>size()</code>：返回队列包含的元素个数，与数组的 length 属性类似。</li><li><code>toString()</code>：将队列中的内容，转成字符串形式。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" title="代码实现"></a>代码实现</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37  </p><p>// 使用 ES6 实现<br>class Queue {<br> items = [];  </p><p> // enqueue() 入队，将元素加入到队列中<br> enqueue(item) {<br> this.items.push(item);<br> }  </p><p> // dequeue() 出队，从队列中删除前端元素，返回删除的元素<br> dequeue() {<br> return this.items.shift();<br> }  </p><p> // front() 查看队列的前端元素<br> front() {<br> return this.items[0];<br> }  </p><p> // isEmpty() 查看队列是否为空<br> isEmpty() {<br> return this.items.length === 0;<br> }  </p><p> // size() 查看队列中元素的个数<br> size() {<br> return this.items.length;<br> }  </p><p> toString() {<br> let result = “”;<br> for (let item of this.items) {<br> result += item + “ “;<br> }<br> return result;<br> }<br>}  </p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" title="测试代码"></a>测试代码</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>const queue = new Queue();  </p><p>// 入队操作<br>queue.enqueue(“a”);<br>queue.enqueue(“b”);<br>queue.enqueue(“c”);<br>queue.enqueue(“d”);<br>console.log(queue.items); //–&gt; [“a”, “b”, “c”, “d”]  </p><p>// 出队操作（先进先出）<br>queue.dequeue();<br>queue.dequeue();<br>console.log(queue.items); //–&gt; [“c”, “d”]  </p><p>// 查看队头的元素<br>console.log(queue.front()); //–&gt; c  </p><p>console.log(queue.isEmpty()); //–&gt; false<br>console.log(queue.size()); //–&gt; 2<br>console.log(queue.toString()); //–&gt; c d  </p><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8" title="队列的应用"></a>队列的应用</h3><p>使用队列实现小游戏：<strong>击鼓传花</strong>。</p><p>分析：传入一组数据集合和设定的数字 number，循环遍历数组内元素，遍历到的元素为指定数字 number 时将该元素删除，直至数组剩下一个元素。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1" title="代码实现"></a>代码实现</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33  </p><p>function passGame(nameList, number) {<br> // 1、new 一个 Queue 对象<br> const queue = new Queue();  </p><p> // 2、将 nameList 里面的每一个元素入队<br> for (const name of nameList) {<br> queue.enqueue(name);<br> }  </p><p> // 3、开始数数<br> // 队列中只剩下 1 个元素时就停止数数<br> while (queue.size() &gt; 1) {<br> // 不是 number 时，重新加入到队尾<br> // 是 number 时，将其删除  </p><p> for (let i = 0; i &lt; number - 1; i++) {<br> // number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中）<br> queue.enqueue(queue.dequeue());<br> }  </p><p> // number 对应这个人，直接从队列中删除<br> // 由于队列没有像数组一样的下标值不能直接取到某一元素，<br> // 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾，<br> // 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除<br> queue.dequeue();<br> }  </p><p> // 4、获取最后剩下的那个人<br> const endName = queue.front();  </p><p> // 5、返回这个人在原数组中对应的索引<br> return nameList.indexOf(endName);<br>}  </p><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-1" title="测试代码"></a>测试代码</h4><p>1<br>2<br>3  </p><p>const names = [“lily”, “lucy”, “tom”, “tony”, “jack”];<br>const targetIndex = passGame(names, 4);<br>console.log(“击鼓传花”, names[targetIndex]); //–&gt; lily  </p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a><a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97" title="优先队列"></a>优先队列</h3><p>优先级队列主要考虑的问题：</p><ul><li>每个元素不再只是一个数据，还包含数据的优先级。</li><li>在添加数据过程中，根据优先级放入到正确位置。</li></ul><h4 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a><a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" title="优先队列的实现"></a>优先队列的实现</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2" title="代码实现"></a>代码实现</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69  </p><p>class PriorityQueue {<br> items = [];  </p><p> // 内部类<br> QueueElement = class {<br> constructor(element, priority) {<br> this.element = element;<br> this.priority = priority;<br> }<br> };  </p><p> // enqueue() 入队，将元素按优先级加入到队列中<br> enqueue(element, priority) {<br> // 根据传入的元素，创建 QueueElement 对象<br> const queueElement = new this.QueueElement(element, priority);  </p><p> // 判断队列是否为空<br> if (this.isEmpty()) {<br> // 如果为空，不用判断优先级，直接添加<br> this.items.push(queueElement);<br> } else {<br> // 定义一个变量记录是否成功添加了新元素<br> let added = false;  </p><p> for (let i = 0; i &lt; this.items.length; i++) {<br> // 让新插入的元素进行优先级比较，priority 值越小，优先级越大<br> if (queueElement.priority &lt; this.items[i].priority) {<br> // 在指定的位置插入元素<br> this.items.splice(i, 0, queueElement);<br> added = true;<br> break;<br> }<br> }  </p><p> // 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后<br> if (!added) {<br> this.items.push(queueElement);<br> }<br> }<br> }  </p><p> // dequeue() 出队，从队列中删除前端元素，返回删除的元素<br> dequeue() {<br> return this.items.shift();<br> }  </p><p> // front() 查看队列的前端元素<br> front() {<br> return this.items[0];<br> }  </p><p> // isEmpty() 查看队列是否为空<br> isEmpty() {<br> return this.items.length === 0;<br> }  </p><p> // size() 查看队列中元素的个数<br> size() {<br> return this.items.length;<br> }  </p><p> toString() {<br> let result = “”;<br> for (let item of this.items) {<br> result += item.element + “-“ + item.priority + “ “;<br> }<br> return result;<br> }<br>}  </p><h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-2" title="测试代码"></a>测试代码</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29  </p><p>const priorityQueue = new PriorityQueue();  </p><p>// 入队<br>priorityQueue.enqueue(“A”, 10);<br>priorityQueue.enqueue(“B”, 15);<br>priorityQueue.enqueue(“C”, 11);<br>priorityQueue.enqueue(“D”, 20);<br>priorityQueue.enqueue(“E”, 18);  </p><p>console.log(priorityQueue.items);<br>//–&gt; output:<br>// QueueElement {element: “A”, priority: 10}<br>// QueueElement {element: “C”, priority: 11}<br>// QueueElement {element: “B”, priority: 15}<br>// QueueElement {element: “E”, priority: 18}<br>// QueueElement {element: “D”, priority: 20}  </p><p>// 出队<br>priorityQueue.dequeue();<br>priorityQueue.dequeue();<br>console.log(priorityQueue.items);<br>//–&gt; output:<br>// QueueElement {element: “B”, priority: 15}<br>// QueueElement {element: “E”, priority: 18}<br>// QueueElement {element: “D”, priority: 20}  </p><p>console.log(priorityQueue.isEmpty()); //–&gt; false<br>console.log(priorityQueue.size()); //–&gt; 3<br>console.log(priorityQueue.toString()); //–&gt; B-15 E-18 D-20  </p><h3 id="数组、栈和队列图解"><a href="#数组、栈和队列图解" class="headerlink" title="数组、栈和队列图解"></a><a href="#%E6%95%B0%E7%BB%84%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A3" title="数组、栈和队列图解"></a>数组、栈和队列图解</h3><p><img src="https://user-images.githubusercontent.com/24516169/88051118-b02ebd80-cb8a-11ea-9acf-4329cbbff6fc.png" alt="array-stack-queue"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法专辑 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据结构与算法（三）栈结构</title>
      <link href="2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-san-zhan-jie-gou/"/>
      <url>2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-san-zhan-jie-gou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。<br>但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。<br>栈和队列就是比较常见的受限的线性结构。</p><p>栈（stack）是一种运算受限的线性表：</p><ul><li><code>LI</code><!-- more -->数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。<br>但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。<br>栈和队列就是比较常见的受限的线性结构。</li></ul><p>栈（stack）是一种运算受限的线性表：</p><ul><li><code>LIFO（last in first out）</code>表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先把拿出去使用。</li><li>其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。</li><li>向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；</li><li>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</li></ul><p>如下图所示：<br><img src="https://user-images.githubusercontent.com/24516169/88035463-caf63780-cb74-11ea-910d-e396a83659ea.png" alt="stack"></p><p>栈的特点：<strong>先进后出，后进先出</strong>。</p><h3 id="程序中的栈结构"><a href="#程序中的栈结构" class="headerlink" title="程序中的栈结构"></a><a href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%84" title="程序中的栈结构"></a>程序中的栈结构</h3><ul><li><p>函数调用栈：A(B(C(D())))：<br>即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</p></li><li><p>递归：<br>为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Stack Overfloat）。</p></li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a><a href="#%E7%BB%83%E4%B9%A0" title="练习"></a>练习</h3><p>题目：有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？</p><ul><li>A：5 4 3 6 1 2 （√）</li><li>B：4 5 3 2 1 6 （√）</li><li>C：3 4 6 5 2 1 （×）</li><li>D：2 3 4 1 5 6 （√）</li></ul><p>题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</p><p>解析：</p><ul><li>A 答案：65 进栈，5 出栈，4 进栈出栈，3 进栈出栈，6 出栈，21 进栈，1 出栈，2 出栈（整体入栈顺序符合 654321）。</li><li>B 答案：654 进栈，4 出栈，5 出栈，3 进栈出栈，2 进栈出栈，1 进栈出栈，6 出栈（整体的入栈顺序符合 654321）。</li><li>C 答案：6543 进栈，3 出栈，4 出栈，之后应该 5 出栈而不是 6，所以错误。</li><li>D 答案：65432 进栈，2 出栈，3 出栈，4 出栈，1 进栈出栈，5 出栈，6 出栈。符合入栈顺序。</li></ul><h3 id="栈结构实现"><a href="#栈结构实现" class="headerlink" title="栈结构实现"></a><a href="#%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0" title="栈结构实现"></a>栈结构实现</h3><h4 id="栈常见的操作"><a href="#栈常见的操作" class="headerlink" title="栈常见的操作"></a><a href="#%E6%A0%88%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C" title="栈常见的操作"></a>栈常见的操作</h4><ul><li><code>push()</code>：添加一个新元素到栈顶位置。</li><li><code>pop()</code>：移除栈顶的元素，同时返回被移除的元素。</li><li><code>peek()</code>：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。</li><li><code>isEmpty()</code>：如果栈里没有任何元素就返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>size()</code>：返回栈里的元素个数。这个方法和数组的 <code>length</code> 属性类似。</li><li><code>toString()</code>：将栈结构的内容以字符串的形式返回。</li></ul><h4 id="JavaScript-代码实现栈结构"><a href="#JavaScript-代码实现栈结构" class="headerlink" title="JavaScript 代码实现栈结构"></a><a href="#JavaScript-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84" title="JavaScript 代码实现栈结构"></a>JavaScript 代码实现栈结构</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38  </p><p>// 使用 ES6 实现<br>class Stack {<br> items = [];  </p><p> // push() 压栈操作，给栈中添加元素<br> push(item) {<br> this.items.push(item);<br> }  </p><p> // pop() 出栈操作，从栈中取出元素，并返回取出的那个元素<br> pop() {<br> return this.items.pop();<br> }  </p><p> // peek() 查看栈顶元素<br> peek() {<br> return this.items[this.items.length - 1];<br> }  </p><p> // isEmpty() 判断栈是否为空<br> isEmpty() {<br> return this.items.length === 0;<br> }  </p><p> // size() 获取栈中元素个数<br> size() {<br> return this.items.length;<br> }  </p><p> // toString() 返回以字符串形式的栈内元素数据<br> toString() {<br> let result = “”;<br> for (let item of this.items) {<br> result += item + “ “;<br> }<br> return result;<br> }<br>}  </p><h4 id="测试栈结构"><a href="#测试栈结构" class="headerlink" title="测试栈结构"></a><a href="#%E6%B5%8B%E8%AF%95%E6%A0%88%E7%BB%93%E6%9E%84" title="测试栈结构"></a>测试栈结构</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13  </p><p>const stack = new Stack();<br>stack.push(1);<br>stack.push(22);<br>stack.push(333);<br>stack.push(4444);<br>console.log(stack.items); //–&gt; [1, 22, 333, 4444]  </p><p>console.log(stack.pop()); //–&gt; 444<br>console.log(stack.pop()); //–&gt; 333<br>console.log(stack.peek()); //–&gt; 22<br>console.log(stack.isEmpty()); //–&gt; false<br>console.log(stack.size()); //–&gt; 2<br>console.log(stack.toString()); //–&gt; 1 22  </p><h3 id="栈结构的简单应用"><a href="#栈结构的简单应用" class="headerlink" title="栈结构的简单应用"></a><a href="#%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8" title="栈结构的简单应用"></a>栈结构的简单应用</h3><p>利用栈结构的特点封装十进制转换为二进制的函数。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" title="代码实现"></a>代码实现</h3><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>// 十进制转换成二进制<br>function dec2bin(dec) {<br> // new 一个 Stack，保存余数<br> const stack = new Stack();  </p><p> // 当不确定循环次数时，使用 while 循环<br> while (dec &gt; 0) {<br> // 除二取余法<br> stack.push(dec % 2); // 获取余数，放入栈中<br> dec = Math.floor(dec / 2);<br> }  </p><p> let binaryString = “”;<br> // 不断地从栈中取出元素（0 或 1），并拼接到一起。<br> while (!stack.isEmpty()) {<br> binaryString += stack.pop();<br> }  </p><p> return binaryString;<br>}  </p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a href="#%E6%B5%8B%E8%AF%95" title="测试"></a>测试</h4><p>1<br>2<br>3  </p><p>// 验证十进制转换二进制方法<br>console.log(dec2bin(10)); //–&gt; 1010<br>console.log(dec2bin(100)); //–&gt; 1100100</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法专辑 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据结构与算法（二）数组结构</title>
      <link href="2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-er-shu-zu-jie-gou/"/>
      <url>2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-er-shu-zu-jie-gou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。<br>数组通常情况下用于存储一系列同一种数据类型的值。<br>但在 JavaScript 里，数组中可以保存不同类型的值。但我们还是要遵守最佳实践，别这么做（大多数语言都没这个能力）。</p><!-- more --><p>几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。<br>数组通常情况下用于存储一系列同一种数据类型的值。<br>但在 JavaScript 里，数组中可以保存不同类型的值。但我们还是要遵守最佳实践，别这么做（大多数语言都没这个能力）。</p><h3 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84" title="创建和初始化数组"></a>创建和初始化数组</h3><ul><li><p>new Array()<br><code>const daysOfWeek = new Array(&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;,&#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;);</code></p></li><li><p>[]<br><code>const daysOfWeek = [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;];</code></p></li></ul><h3 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a><a href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" title="数组常见操作"></a>数组常见操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0" title="添加元素"></a>添加元素</h4><ul><li><p>添加一个元素到数组的最后位置 <code>array.push(item)</code></p></li><li><p>在数组首位插入一个元素 <code>array.unshift(item)</code></p></li><li><p>在指定索引位置插入元素 <code>array.splice(index, 0, item)</code><br>splice() 第二个参数为 0 时，表示插入数据。</p><p>1<br>2<br>3<br>4  </p><p>let myArray = [1, 2, 3];<br>// 在 索引 0 的位置，插入 A<br>myArray.splice(0, 0, “A”);<br>console.log(myArray); //–&gt; [‘A’, 1, 2, 3]  </p></li></ul><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0" title="删除元素"></a>删除元素</h4><ul><li><p>删除数组最后的元素 <code>array.pop(item)</code></p></li><li><p>删除数组首位的元素 <code>array.shift(item)</code></p></li><li><p>删除指定索引位置的元素 <code>array.splice(start, number)</code><br>例如：</p><p>1<br>2<br>3<br>4  </p><p>let myArray2 = [1, 2, 3, 4, 5];<br>// 删除索引 4 位置起，2 个元素<br>myArray2.splice(4, 2);<br>console.log(myArray2); //–&gt; [1, 2, 3]  </p></li></ul><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a><a href="#%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0" title="修改元素"></a>修改元素</h3><ul><li><p>修改指定索引位置的元素 <code>array.splice(index, 1, item)</code></p><p>1<br>2<br>3<br>4  </p><p>let myArray3 = [1, 2, 3, 4, 5, 6];<br>// 修改 索引 1 的位置的元素为 AA<br>myArray2.splice(1, 1, “AA”);<br>console.log(myArray3); //–&gt; [1, “AA”, 3, 4, 5, 6]  </p></li><li><p>修改指定索引位置的几个元素 <code>array.splice(index, number, item)</code></p><p>1<br>2<br>3<br>4  </p><p>let myArray4 = [1, 2, 3, 4, 5, 6, 7];<br>// 在 索引 2 的位置起，修改两个元素为 AA BB<br>myArray2.splice(2, 2, “AA”, “BB”);<br>console.log(myArray3); //–&gt; [1, 2, “AA”, “BB”, 5, 6, 7]</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数组 </tag>
            
            <tag> 算法专辑 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据结构与算法（一）前言</title>
      <link href="2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-yi-qian-yan/"/>
      <url>2020/07/21/javascript-shu-ju-jie-gou-yu-suan-fa-yi-qian-yan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F" title="什么是数据结构？"></a>什么是数据结构？</h2><!-- more --><h2 id="什么是数据结构？-1"><a href="#什么是数据结构？-1" class="headerlink" title="什么是数据结构？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F" title="什么是数据结构？"></a>什么是数据结构？</h2><h3 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89" title="数据结构的定义"></a>数据结构的定义</h3><ul><li><p>官方定义</p><p>无</p></li><li><p>民间定义</p><ul><li>“数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。” — 《数据结构、算法与应用》</li><li>“数据结构是 ADT（抽象数据类型 Abstract Data Type）的物理实现。” — 《数据结构与算法分析》</li><li>“数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。” —中文维基百科</li></ul></li><li><p>从自己角度认识</p><p>在计算机中，存储和组织数据的方式。</p></li></ul><h3 id="数据结构在生活中应用"><a href="#数据结构在生活中应用" class="headerlink" title="数据结构在生活中应用"></a><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%BA%94%E7%94%A8" title="数据结构在生活中应用"></a>数据结构在生活中应用</h3><p>我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储呢?</p><p>例如：一个庞大的图书馆中存放了大量的书籍，我们不仅仅要把书放进入，还应该在合适的时候能够取出来。</p><p>图书摆放要使得两个相关操作方便实现：</p><ul><li>操作 1：新书怎么插入？</li><li>操作 2：怎么找到某本指定的书？</li></ul><p>图书各种摆放方式：</p><ul><li><p>方法 1：随便放</p><ul><li>操作 1：哪里有空位放哪里。</li><li>操作 2：找某本书，累死。</li></ul></li><li><p>方法 2：按照书名的拼音字母顺序排放</p><ul><li>操作 1：新进一本《阿 Q 正传》， 按照字母顺序找到位置，插入。</li><li>操作 2：二分查找法。</li></ul></li><li><p>方法 3：把书架划分成几块区域，按照类别存放，类别中按照字母顺序</p><ul><li>操作 1：先定类别，二分查找确定位置，移出空位。</li><li>操作 2：先定类别，再二分查找。</li></ul></li></ul><p>结论：</p><ul><li>解决问题方法的效率，根据数据的组织方式有关。</li><li>计算机中存储的数据量相对于图书馆的书籍来说数据量更大，数据更加多。</li><li>以什么样的方式，来存储和组织我们的数据才能在使用数据时更加方便呢?</li><li>这就是数据结构需要考虑的问题。</li></ul><h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="常见的数据结构"></a>常见的数据结构</h3><ul><li>数组（Aarray）</li><li>栈（Stack）</li><li>链表（Linked List）</li><li>图（Graph）</li><li>散列表（Hash）</li><li>队列（Queue）</li><li>树（Tree）</li><li>堆（Heap）</li></ul><blockquote><p>注意：数据结构与算法与语言无关，常见的编程语言都有<strong>直接或间接</strong>的使用上述常见的数据结构。</p></blockquote><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%EF%BC%9F" title="什么是算法？"></a>什么是算法？</h2><h3 id="算法（Algorithm）的定义"><a href="#算法（Algorithm）的定义" class="headerlink" title="算法（Algorithm）的定义"></a><a href="#%E7%AE%97%E6%B3%95%EF%BC%88Algorithm%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89" title="算法（Algorithm）的定义"></a>算法（Algorithm）的定义</h3><ul><li>一个有限指令集，每条指令的描述不依赖于语言。</li><li>接收一些输入（有些情况下不需要输入）。</li><li>产生输出。</li><li>一定在有限步骤之后终止。</li></ul><h3 id="算法通俗理解"><a href="#算法通俗理解" class="headerlink" title="算法通俗理解"></a><a href="#%E7%AE%97%E6%B3%95%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3" title="算法通俗理解"></a>算法通俗理解</h3><ul><li>Algorithm 这个单词本意就是解决问题的办法/步骤逻辑。</li><li>数据结构的实现，离不开算法。</li></ul><h3 id="算法案例"><a href="#算法案例" class="headerlink" title="算法案例"></a><a href="#%E7%AE%97%E6%B3%95%E6%A1%88%E4%BE%8B" title="算法案例"></a>算法案例</h3><p>假如上海和杭州之间有一条高架线，高架线长度是 1,000,000 米，有一天高架线中有其中一米出现了故障，请你想出一种算法，可以快速定位到处问题的地方。</p><ul><li><p>线性查找</p><ul><li>从上海的起点开始一米一米的排查，最终一定能找到出问题的线段。</li><li>但是如果线段在另一头，我们需要排查 1,000,000 次，这是最坏的情况，平均需要 500,000 次。</li></ul></li><li><p>二分查找</p><ul><li>从中间位置开始排查，看一下问题出在上海到中间位置，还是中间到杭州的位置。</li><li>查找对应的问题后，再从中间位置分开，重新锁定一般的路程。</li><li>最坏的情况，需要多少次可以排查完呢? 最坏的情况是 20 次就可以找到出问题的地方。</li><li>怎么计算出来的呢? log(1000000, 2)，以 2 位底，1000000 的对数 ≈ 20。</li></ul></li></ul><p>结论：<br>你会发现，解决问题的办法有很多，但是好的算法对比于差的算法，效率天壤之别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法专辑 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据结构与算法学习笔记（专辑）</title>
      <link href="2020/07/20/javascript-shu-ju-jie-gou-yu-suan-fa-xue-xi-bi-ji-zhuan-ji/"/>
      <url>2020/07/20/javascript-shu-ju-jie-gou-yu-suan-fa-xue-xi-bi-ji-zhuan-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 数据结构与算法学习笔记（专辑）是作者根据哔哩哔哩<a href="https://www.bilibili.com/video/BV1x7411L7Q7?p=1">《coderwhy 的 J</a></p><!-- more --><p>JavaScript 数据结构与算法学习笔记（专辑）是作者根据哔哩哔哩<a href="https://www.bilibili.com/video/BV1x7411L7Q7?p=1">《coderwhy 的 JavaScript 数据结构与算法》</a>视频教程整理而得，仅供大家查阅，欢迎指出错误。</p><p><strong>目录</strong></p><ul><li><a href="/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80/">JavaScript 数据结构与算法（一）前言</a></li><li><a href="/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84/">JavaScript 数据结构与算法（二）数组结构</a></li><li><a href="/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%88%E7%BB%93%E6%9E%84/">JavaScript 数据结构与算法（三）栈结构</a></li><li><a href="/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/">JavaScript 数据结构与算法（四）队列结构</a></li><li><a href="/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/">JavaScript 数据结构与算法（五）单向链表结构</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法专辑 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 常用的正则表达式汇总</title>
      <link href="2020/07/01/js-chang-yong-de-zheng-ze-biao-da-shi-hui-zong/"/>
      <url>2020/07/01/js-chang-yong-de-zheng-ze-biao-da-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此文收录我在开发过程中所用到的以及在各种业务场景下常用到的正则表达式，持续更新…</p><!-- more --><p>此文收录我在开发过程中所用到的以及在各种业务场景下常用到的正则表达式，持续更新…</p><h1 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a><a href="#JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h1><p>正则表达式（英语：Regular Expression，在代码中常简写为 <code>regex</code>、<code>regexp</code> 或 <code>RE</code>）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</p><p>更多介绍，请参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li><li><a href="https://www.runoob.com/js/js-regexp.html">https://www.runoob.com/js/js-regexp.html</a></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a><a href="#%E8%AF%AD%E6%B3%95" title="语法"></a>语法</h2><p>1  </p><p>/正则表达式主体/修饰符(可选)  </p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>eg:<br>const RE = /xpoet/i;  </p><p>解析：<br>/xpoet/i 是一个正则表达式。<br>xpoet 是一个正则表达式主体 (用于检索)。<br>i 是一个修饰符 (搜索不区分大小写)。  </p><h2 id="常用的匹配规则"><a href="#常用的匹配规则" class="headerlink" title="常用的匹配规则"></a><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99" title="常用的匹配规则"></a>常用的匹配规则</h2><ul><li>验证数字：<code>^[0-9]*$</code>。</li><li>验证 n 位的数字：<code>^\d&#123;n&#125;$</code>。</li><li>验证至少 n 位数字：<code>^\d&#123;n,&#125;$</code>。</li><li>验证 m-n 位的数字：<code>^\d&#123;m,n&#125;$</code>。</li><li>验证零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code>。</li><li>验证有两位小数的正实数：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code>。</li><li>验证有1-3位小数的正实数：<code>^[0-9]+(.[0-9]&#123;1,3&#125;)?$</code>。</li><li>验证非零的正整数：<code>^\+?[1-9][0-9]*$</code>。</li><li>验证非零的负整数：<code>^\-[1-9][0-9]*$</code>。</li><li>验证非负整数（正整数 + 0）： <code>^\d+$</code>。</li><li>验证非正整数（负整数 + 0）： <code>^((-\d+)|(0+))$</code>。</li><li>验证长度为 3 的字符：<code>^.&#123;3&#125;$</code>。</li><li>验证由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code>。</li><li>验证由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code>。</li><li>验证由26个小写英文字母组成的字符串：<code>^[a-z]+$</code>。</li><li>验证由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code>。</li><li>验证由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$</code>。</li><li>验证用户密码（格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线）：<code>^[a-zA-Z]\w&#123;5,17&#125;$</code>。</li><li>验证是否含有 <code>^%&amp;&#39;,;=?$\&quot;</code> 等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code>。</li><li>验证汉字：<code>^[\u4e00-\u9fa5],&#123;0,&#125;$</code>。</li><li>验证Email地址：<code>^\w+[-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code>。</li><li>验证InternetURL：<code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$</code>。</li><li>验证电话号码（格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX）：<code>^(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-)?\d&#123;7,8&#125;$</code>。</li><li>验证身份证号（15位或18位数字）：<code>^\d&#123;15&#125;|\d&#123;&#125;18$</code>。</li><li>验证一年的12个月（格式为：“01”-“09”和“1”“12”）：<code>^(0?[1-9]|1[0-2])$</code>。</li><li>验证一个月的31天（格式为：01、09和1、31）：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code>。</li><li>整数：<code>^-?\d+$</code>。</li><li>非负浮点数（正浮点数 + 0）：<code>^\d+(\.\d+)?$</code>。</li><li>正浮点数：<code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code>。</li><li>非正浮点数（负浮点数 + 0）：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code>。</li><li>负浮点数：<code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code>。</li><li>浮点数：<code>^(-?\d+)(\.\d+)?$</code>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15个必须掌握的 JavaScript 数组方法</title>
      <link href="2020/06/09/15-ge-bi-xu-zhang-wo-de-javascript-shu-zu-fang-fa/"/>
      <url>2020/06/09/15-ge-bi-xu-zhang-wo-de-javascript-shu-zu-fang-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 JavaScript 中，数组是一个特殊的变量，用于存储不同的元素。它具有一些内置属性和方法，可用于根据需要添加，删除，迭代或操作数。并且了解 JavaScript 数组方法可以提升你的开发技能。</p><p>在本文中，我们将介绍 15 种关于 JavaScript</p><!-- more --><p>在 JavaScript 中，数组是一个特殊的变量，用于存储不同的元素。它具有一些内置属性和方法，可用于根据需要添加，删除，迭代或操作数。并且了解 JavaScript 数组方法可以提升你的开发技能。</p><p>在本文中，我们将介绍 15 种关于 JavaScript 的数组方法，这些方法可以帮助你正确地处理数据。</p><ul><li>some()</li><li>reduce()</li><li>Every()</li><li>map()</li><li>flat()</li><li>filter()</li><li>forEach()</li><li>findIndex()</li><li>find()</li><li>sort()</li><li>concat()</li><li>fill()</li><li>includes()</li><li>reverse()</li><li>flatMap()</li></ul><h4 id="some"><a href="#some" class="headerlink" title="some()"></a><a href="#some" title="some()"></a>some()</h4><p>此方法为参数传递的函数测试数组。如果有一个元素与测试元素匹配，则返回 <code>true</code>，否则返回 <code>false</code>。</p><blockquote><p><code>some()</code> 不会对空数组进行检测；<code>some()</code> 不会改变原始数组。</p></blockquote><p>1<br>2<br>3  </p><p>const myAwesomeArray = [“a”, “b”, “c”, “d”, “e”];<br>myAwesomeArray.some(item =&gt; item === “d”);<br>//——-&gt; Output : true  </p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><a href="#reduce" title="reduce()"></a>reduce()</h4><p>此方法接收一个函数作为累加器。它为数组中的每个元素依次执行回调函数，不包括数组中被删除或者从未被赋值的元素。函数应用于累加器，数组中的每个值最后只返回一个值。</p><blockquote><p><code>reduce()</code> 方法接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组。</p></blockquote><p>1<br>2<br>3<br>4  </p><p>const myAwesomeArray = [1, 2, 3, 4, 5];<br>myAwesomeArray.reduce((total, value) =&gt; total * value);<br>// 1 * 2 * 3 * 4 * 5<br>//——-&gt; Output = 120  </p><h4 id="Every"><a href="#Every" class="headerlink" title="Every()"></a><a href="#Every" title="Every()"></a>Every()</h4><p>此方法是对数组中每项运行给定函数，如果数组的每个元素都与测试匹配，则返回 <code>true</code>，反之则返回 <code>false</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>const myAwesomeArray = [“a”, “b”, “c”, “d”, “e”];<br>myAwesomeArray.every(item =&gt; item === “d”);<br>// ——-&gt; Output : false  </p><p>const myAwesomeArray2 = [“a”, “a”, “a”, “a”, “a”];<br>myAwesomeArray2.every(item =&gt; item === “a”);<br>//——-&gt; Output : true  </p><h4 id="map"><a href="#map" class="headerlink" title="map()"></a><a href="#map" title="map()"></a>map()</h4><p>该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它按照原始数组元素顺序依次处理元素。</p><blockquote><p><code>map()</code> 不会对空数组进行检测；<code>map()</code> 不会改变原始数组。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>const myAwesomeArray = [5, 4, 3, 2, 1];<br>myAwesomeArray.map(x =&gt; x * x);<br>//——-&gt; Output : 25<br>//                  16<br>//                  9<br>//                  4<br>//                  1  </p><h4 id="flat"><a href="#flat" class="headerlink" title="flat()"></a><a href="#flat" title="flat()"></a>flat()</h4><p>此方法创建一个新数组，其中包含子数组上的 <code>holden</code> 元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。</p><p>1<br>2<br>3  </p><p>const myAwesomeArray = [[1, 2], [3, 4], 5];<br>myAwesomeArray.flat();<br>//——-&gt; Output : [1, 2, 3, 4, 5]  </p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><a href="#filter" title="filter()"></a>filter()</h4><p>该方法接收一个函数作为参数。并返回一个新数组，该数组包含该数组的所有元素，作为参数传递的过滤函数对其返回 <code>true</code>。</p><blockquote><p><code>filter()</code> 方法是对数据中的元素进行过滤，也就是说是不能修改原数组中的数据，只能读取原数组中的数据，<code>callback</code> 需要返回布尔值；为 <code>true</code> 的时候，对应的元素留下来；为 <code>false</code> 的时候，对应的元素过滤掉。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>const myAwesomeArray = [<br> { id: 1, name: “john” },<br> { id: 2, name: “Ali” },<br> { id: 3, name: “Mass” },<br> { id: 4, name: “Mass” }<br>];<br>myAwesomeArray.filter(element =&gt; element.name === “Mass”);<br>//——-&gt; Output : 0:{id: 3, name: “Mass”},<br>//                  1:{id: 4, name: “Mass”}  </p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><a href="#forEach" title="forEach()"></a>forEach()</h4><p>此方法用于调用数组的每个元素。并将元素传递给回调函数。</p><blockquote><p><code>forEach()</code> 对于空数组是不会执行回调函数的。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>const myAwesomeArray = [<br> { id: 1, name: “john” },<br> { id: 2, name: “Ali” },<br> { id: 3, name: “Mass” }<br>];<br>myAwesomeArray.forEach(element =&gt; console.log(element.name));<br>//——-&gt; Output : john<br>//                  Ali<br>//                  Mass  </p><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a><a href="#findIndex" title="findIndex()"></a>findIndex()</h4><p>此方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。它为数组中的每个元素都调用一次函数执行，当数组中的元素在测试条件时返回 <code>true</code> 时, <code>findIndex()</code> 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 <code>-1</code>。</p><blockquote><p><code>findIndex()</code> 对于空数组，函数是不会执行的， <code>findIndex()</code> 并没有改变数组的原始值。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11  </p><p>const myAwesomeArray = [<br> { id: 1, name: “john” },<br> { id: 2, name: “Ali” },<br> { id: 3, name: “Mass” }<br>];  </p><p>myAwesomeArray.findIndex(element =&gt; element.id === 3);<br>// ——-&gt; Output : 2  </p><p>myAwesomeArray.findIndex(element =&gt; element.id === 7);<br>//——-&gt; Output : -1  </p><h4 id="find"><a href="#find" class="headerlink" title="find()"></a><a href="#find" title="find()"></a>find()</h4><p>此方法返回通过测试（函数内判断）的数组的第一个元素的值。<code>find()</code> 方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时回 <code>true</code> 时, <code>find()</code> 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 <code>undefined</code>。</p><blockquote><p><code>find()</code> 对于空数组，函数是不会执行的；<code>find()</code> 并没有改变数组的原始值。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11  </p><p>const myAwesomeArray = [<br> { id: 1, name: “john” },<br> { id: 2, name: “Ali” },<br> { id: 3, name: “Mass” }<br>];  </p><p>myAwesomeArray.find(element =&gt; element.id === 3);<br>// ——-&gt; Output : {id: 3, name: “Mass”}  </p><p>myAwesomeArray.find(element =&gt; element.id === 7);<br>//——-&gt; Output : undefined  </p><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a><a href="#sort" title="sort()"></a>sort()</h4><p>此方法接收一个函数作为参数。它对数组的元素进行排序并返回它。也可以使用含有参数的 <code>sort()</code> 方法进行排序。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>const myAwesomeArray = [5, 4, 3, 2, 1];  </p><p>// Sort from smallest to largest<br>myAwesomeArray.sort((a, b) =&gt; a - b);<br>//  ——-&gt; Output : [1, 2, 3, 4, 5]  </p><p>// Sort from largest to smallest<br>myAwesomeArray.sort((a, b) =&gt; b - a);<br>//——-&gt; Output : [5, 4, 3, 2, 1]  </p><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a><a href="#concat" title="concat()"></a>concat()</h4><p>此方法用于连接两个或多个数组/值，它不会改变现有的数组。而仅仅返回被连接数组的一个新数组。</p><p>1<br>2<br>3<br>4  </p><p>const myAwesomeArray = [1, 2, 3, 4, 5];<br>const myAwesomeArray2 = [10, 20, 30, 40, 50];<br>myAwesomeArray.concat(myAwesomeArray2);<br>//——-&gt; Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]  </p><h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a><a href="#fill" title="fill()"></a>fill()</h4><p>此方法的作用是使用一个固定值来替换数组中的元素。该固定值可以是字母、数字、字符串、数组等等。它还有两个可选参数，表示填充起来的开始位置（默认为 <code>0</code>）与结束位置（默认为 <code>array.length</code>）。</p><blockquote><p><code>fill()</code> 方法用于将一个固定值替换数组的元素。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>const myAwesomeArray = [1, 2, 3, 4, 5];<br>// The first argument  (0) is the value<br>// The second argument (1) is the starting index<br>// The third argument  (3) is the ending index<br>myAwesomeArray.fill(0, 1, 3);<br>//——-&gt; Output : [1, 0, 0, 4, 5]  </p><h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a><a href="#includes" title="includes()"></a>includes()</h4><p>此方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 <code>true</code>，否则返回 <code>false</code>。</p><blockquote><p><code>includes()</code> 方法区分大小写。</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>const myAwesomeArray = [1, 2, 3, 4, 5];<br>myAwesomeArray.includes(3);<br>// ——-&gt; Output : true  </p><p>myAwesomeArray.includes(8);<br>// ——-&gt; Output : false  </p><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a><a href="#reverse" title="reverse()"></a>reverse()</h4><p>此方法用于颠倒数组中元素的顺序。第一个元素成为最后一个，最后一个元素将成为第一个。</p><p>1<br>2<br>3  </p><p>const myAwesomeArray = [“e”, “d”, “c”, “b”, “a”];<br>myAwesomeArray.reverse();<br>// ——-&gt; Output : [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]  </p><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a><a href="#flatMap" title="flatMap()"></a>flatMap()</h4><p>该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了 <code>flat()</code> 和 <code>map()</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>const myAwesomeArray = [[1], [2], [3], [4], [5]];<br>myAwesomeArray.flatMap(arr =&gt; arr * 10);<br>//——-&gt; Output : [10, 20, 30, 40, 50]<br>// With .flat() and .map()<br>myAwesomeArray.flat().map(arr =&gt; arr * 10);<br>//——-&gt; Output : [10, 20, 30, 40, 50]</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文文案排版指北</title>
      <link href="2020/05/06/zhong-wen-wen-an-pai-ban-zhi-bei/"/>
      <url>2020/05/06/zhong-wen-wen-an-pai-ban-zhi-bei/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="中文文案排版指北"><a href="#中文文案排版指北" class="headerlink" title="中文文案排版指北"></a><a href="#%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97" title="中文文案排版指北"></a>中文文案排版指北</h1><p>统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a><a href="#%E7%A9%BA%E6%A0%BC" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p><p>与大家共勉之。」——<a href="https://github.com/vinta/pangu.js">vinta/paranoid-auto-spacing</a></p><!-- more --><h1 id="中文文案排版指北-1"><a href="#中文文案排版指北-1" class="headerlink" title="中文文案排版指北"></a><a href="#%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97" title="中文文案排版指北"></a>中文文案排版指北</h1><p>统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。</p><h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a><a href="#%E7%A9%BA%E6%A0%BC" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p><p>与大家共勉之。」——<a href="https://github.com/vinta/pangu.js">vinta/paranoid-auto-spacing</a></p><h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a><a href="#%E4%B8%AD%E8%8B%B1%E6%96%87%E4%B9%8B%E9%97%B4%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%A9%BA%E6%A0%BC" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a><a href="#%E4%B8%AD%E6%96%87%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%A9%BA%E6%A0%BC" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a href="#数字与单位之间需要增加空格" class="headerlink" title="数字与单位之间需要增加空格"></a><a href="#%E6%95%B0%E5%AD%97%E4%B8%8E%E5%8D%95%E4%BD%8D%E4%B9%8B%E9%97%B4%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%A9%BA%E6%A0%BC" title="数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a><a href="#%E5%85%A8%E8%A7%92%E6%A0%87%E7%82%B9%E4%B8%8E%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%8A%A0%E7%A9%BA%E6%A0%BC" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h3 id="用-text-spacing-来挽救？"><a href="#用-text-spacing-来挽救？" class="headerlink" title="用 text-spacing 来挽救？"></a><a href="#%E7%94%A8-text-spacing-%E6%9D%A5%E6%8C%BD%E6%95%91%EF%BC%9F" title="用 text-spacing 来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h3><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx"><code>-ms-text-autospace</code></a> 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a><a href="#%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7" title="标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a href="#不重复使用标点符号" class="headerlink" title="不重复使用标点符号"></a><a href="#%E4%B8%8D%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7" title="不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a><a href="#%E5%85%A8%E8%A7%92%E5%92%8C%E5%8D%8A%E8%A7%92" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a><a href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E8%A7%92%E4%B8%AD%E6%96%87%E6%A0%87%E7%82%B9" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a><a href="#%E6%95%B0%E5%AD%97%E4%BD%BF%E7%94%A8%E5%8D%8A%E8%A7%92%E5%AD%97%E7%AC%A6" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其内容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其内容使用半角标点"></a><a href="#%E9%81%87%E5%88%B0%E5%AE%8C%E6%95%B4%E7%9A%84%E8%8B%B1%E6%96%87%E6%95%B4%E5%8F%A5%E3%80%81%E7%89%B9%E6%AE%8A%E5%90%8D%E8%AF%8D%EF%BC%8C%E5%85%B6%E5%86%85%E5%AE%B9%E4%BD%BF%E7%94%A8%E5%8D%8A%E8%A7%92%E6%A0%87%E7%82%B9" title="遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a><a href="#%E5%90%8D%E8%AF%8D" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a><a href="#%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a><a href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%9C%B0%E9%81%93%E7%9A%84%E7%BC%A9%E5%86%99" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a><a href="#%E4%BA%89%E8%AE%AE" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a><a href="#%E9%93%BE%E6%8E%A5%E4%B9%8B%E9%97%B4%E5%A2%9E%E5%8A%A0%E7%A9%BA%E6%A0%BC" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a href="#简体中文使用直角引号" class="headerlink" title="简体中文使用直角引号"></a><a href="#%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8%E7%9B%B4%E8%A7%92%E5%BC%95%E5%8F%B7" title="简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><a href="#%E5%B7%A5%E5%85%B7" title="工具"></a>工具</h2><p>仓库</p><p>语言</p><p><a href="https://github.com/vinta/paranoid-auto-spacing">vinta/paranoid-auto-spacing</a></p><p>JavaScript</p><p><a href="https://github.com/huei90/pangu.node">huei90/pangu.node</a></p><p>Node.js</p><p><a href="https://github.com/huacnlee/auto-correct">huacnlee/auto-correct</a></p><p>Ruby</p><p><a href="https://github.com/sparanoid/space-lover">sparanoid/space-lover</a></p><p>PHP (WordPress)</p><p><a href="https://github.com/NauxLiu/auto-correct">nauxliu/auto-correct</a></p><p>PHP</p><p><a href="https://github.com/jxlwqq/chinese-typesetting">jxlwqq/chinese-typesetting</a></p><p>PHP</p><p><a href="https://github.com/hotoo/pangu.vim">hotoo/pangu.vim</a></p><p>Vim</p><p><a href="https://github.com/sparanoid/grunt-auto-spacing">sparanoid/grunt-auto-spacing</a></p><p>Node.js (Grunt)</p><p><a href="https://github.com/hjiang/scripts/blob/master/add-space-between-latin-and-cjk">hjiang/scripts/add-space-between-latin-and-cjk</a></p><p>Python</p><p><a href="https://github.com/hustcc/hint">hustcc/hint</a></p><p>Python</p><p><a href="https://github.com/studygolang/autocorrect">studygolang/autocorrect</a></p><p>Go</p><h2 id="谁在这样做？"><a href="#谁在这样做？" class="headerlink" title="谁在这样做？"></a><a href="#%E8%B0%81%E5%9C%A8%E8%BF%99%E6%A0%B7%E5%81%9A%EF%BC%9F" title="谁在这样做？"></a>谁在这样做？</h2><p>网站</p><p>文案</p><p>UGC</p><p><a href="https://www.apple.com/cn/">Apple 中国</a></p><p>是</p><p>N/A</p><p><a href="https://www.apple.com/hk/">Apple 香港</a></p><p>是</p><p>N/A</p><p><a href="https://www.apple.com/tw/">Apple 台湾</a></p><p>是</p><p>N/A</p><p><a href="https://www.microsoft.com/zh-cn/">Microsoft 中国</a></p><p>是</p><p>N/A</p><p><a href="https://www.microsoft.com/zh-hk/">Microsoft 香港</a></p><p>是</p><p>N/A</p><p><a href="https://www.microsoft.com/zh-tw/">Microsoft 台湾</a></p><p>是</p><p>N/A</p><p><a href="https://leancloud.cn/">LeanCloud</a></p><p>是</p><p>N/A</p><p><a href="https://www.v2ex.com/">V2EX</a></p><p>是</p><p>是</p><p><a href="https://apple4us.com/">Apple4us</a></p><p>是</p><p>N/A</p><p><a href="https://ruby-china.org/">Ruby China</a></p><p>是</p><p>标题达成</p><p><a href="https://phphub.org/">PHPHub</a></p><p>是</p><p>标题达成</p><p><a href="https://sspai.com/">少数派</a></p><p>是</p><p>N/A</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.thoughtco.com/guidelines-for-using-capital-letters-1691724">Guidelines for Using Capital Letters - ThoughtCo.</a></li><li><a href="https://en.wikipedia.org/wiki/Letter_case">Letter case - Wikipedia</a></li><li><a href="https://en.oxforddictionaries.com/grammar/punctuation">Punctuation - Oxford Dictionaries</a></li><li><a href="https://owl.english.purdue.edu/owl/section/1/6/">Punctuation - The Purdue OWL</a></li><li><a href="https://www.wikihow.com/Use-English-Punctuation-Correctly">How to Use English Punctuation Correctly - wikiHow</a></li><li><a href="https://zh.opensuse.org/index.php?title=Help:%E6%A0%BC%E5%BC%8F">格式 - openSUSE</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E8%99%9F">引号 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%96%91%E5%95%8F%E9%A9%9A%E5%98%86%E8%99%9F">疑问惊叹号 - 维基百科</a></li></ul><p><strong><em>注：本文转载 <a href="https://github.com/sparanoid/chinese-copywriting-guidelines">https://github.com/sparanoid/chinese-copywriting-guidelines</a></em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术教程 </tag>
            
            <tag> 文案排版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>千呼万唤始出来，Hexo 主题 ILS 正式发布</title>
      <link href="2020/04/07/qian-hu-wan-huan-shi-chu-lai-hexo-zhu-ti-ils-zheng-shi-fa-bu/"/>
      <url>2020/04/07/qian-hu-wan-huan-shi-chu-lai-hexo-zhu-ti-ils-zheng-shi-fa-bu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如你所见，ILS 界面设计十分简洁、清爽，但功能齐全、不失优雅，这正是 ILS 的开发理念。也曾尝试过花里胡哨，发现不仅容易审美疲劳，而且背驰了写博客的初衷，记录生活、展示文字，应该才是搭建博客网站的最终追求，为此 ILS 应运而生。简约大气、不缺美感、突出内容、化繁为简、配置简单、长期维护，如果你也喜欢或认可这些主题特点，一起来折腾吧~</p><p>关于主题名称 <strong>“ILS”</strong> 的由来：在主题开发之初，作者想到的几个名字都被已被用，词穷了，后来干脆将名字取自 <strong>“I Like Simple「我喜欢简单」”</strong> 首字母，就是这么简单。</p><!-- more --><p>如你所见，ILS 界面设计十分简洁、清爽，但功能齐全、不失优雅，这正是 ILS 的开发理念。也曾尝试过花里胡哨，发现不仅容易审美疲劳，而且背驰了写博客的初衷，记录生活、展示文字，应该才是搭建博客网站的最终追求，为此 ILS 应运而生。简约大气、不缺美感、突出内容、化繁为简、配置简单、长期维护，如果你也喜欢或认可这些主题特点，一起来折腾吧~</p><p>关于主题名称 <strong>“ILS”</strong> 的由来：在主题开发之初，作者想到的几个名字都被已被用，词穷了，后来干脆将名字取自 <strong>“I Like Simple「我喜欢简单」”</strong> 首字母，就是这么简单。</p><p>同时，非常欢迎感兴趣的同学 <a href="https://juejin.im/post/6844903856971710477">Pull Request</a> 加入到该主题的开发中（成为该项目的贡献者），按你的意愿来打磨 ILS。</p><h2 id="Features-功能特性"><a href="#Features-功能特性" class="headerlink" title="Features 功能特性"></a><a href="#Features-%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7" title="Features 功能特性"></a>Features 功能特性</h2><h3 id="Completed-已完成"><a href="#Completed-已完成" class="headerlink" title="Completed 已完成"></a><a href="#Completed-%E5%B7%B2%E5%AE%8C%E6%88%90" title="Completed 已完成"></a>Completed 已完成</h3><ul><li>恰到好处的留白，简约大气。</li><li>响应式设计，适配多种终端。</li><li>日间/夜间模式自由切换。</li><li>多种代码高亮方案。</li><li>语言国际化，支持中/英文。</li><li>内置多款评论插件。</li><li>支持全站文章搜索。</li><li>支持文章顶置。</li><li>代码块一键复制。</li><li>TOC 目录结构。</li><li>RSS 订阅。</li><li>网站 UV 和 PV 统计。</li><li>文章阅读次数统计。</li><li>文章字数统计。</li><li>文章阅读时长统计。</li><li>页面滚动进度条提示。</li><li>一键快速回到顶部。</li><li>无 jQuery，代码精简。</li></ul><h3 id="Unfinished-未完成"><a href="#Unfinished-未完成" class="headerlink" title="Unfinished 未完成"></a><a href="#Unfinished-%E6%9C%AA%E5%AE%8C%E6%88%90" title="Unfinished 未完成"></a>Unfinished 未完成</h3><ul><li>文章版权信息</li><li>文章支持显示公式</li><li>在线更改字体和字号</li><li>打赏功能</li><li>……</li></ul><h2 id="Get-start-快速开始"><a href="#Get-start-快速开始" class="headerlink" title="Get start 快速开始"></a><a href="#Get-start-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B" title="Get start 快速开始"></a>Get start 快速开始</h2><p>在开始使用主题之前，强烈建议你先阅读 「Easy Hexo 团队」撰写的 Hexo 教程！<br>链接：<a href="https://easyhexo.com/">https://easyhexo.com/</a></p><h3 id="Install-安装"><a href="#Install-安装" class="headerlink" title="Install 安装"></a><a href="#Install-%E5%AE%89%E8%A3%85" title="Install 安装"></a>Install 安装</h3><ul><li><p>使用 Git SSH</p><p>1  </p><p>git clone –depth=1 <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:XPoet/hexo-theme-ils.git themes/ils  </p><p>该方式获取的是 Master 分支最新代码，包含该主题最新的功能，但无法保证完全稳定。</p></li><li><p>下载 Release 版本</p><p><a href="https://github.com/XPoet/hexo-theme-ils/releases">点击此处进入该主题 Releases 版本下载页面</a> 请优先下载最新版本，下载完成后解压到 Hexo 博客目录的 themes 文件夹里面并重命名为 <code>ils</code>。</p></li></ul><h3 id="Enable-启用"><a href="#Enable-启用" class="headerlink" title="Enable 启用"></a><a href="#Enable-%E5%90%AF%E7%94%A8" title="Enable 启用"></a>Enable 启用</h3><p>Modify <code>theme</code> setting in <code>_config.yml</code> to <code>ils</code>.<br>修改博客目录下的 <code>_config.yml</code> 配置文件，将 <code>theme</code> 设置为 <code>ils</code> 。</p><p>1<br>2<br>3<br>4  </p><p># Extensions<br>## Plugins: <a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a><br>## Themes: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>theme: ils  </p><h3 id="Update-更新"><a href="#Update-更新" class="headerlink" title="Update 更新"></a><a href="#Update-%E6%9B%B4%E6%96%B0" title="Update 更新"></a>Update 更新</h3><ul><li><p>使用 Git SSH</p><p>1<br>2  </p><p>cd themes/ils<br>git pull  </p></li><li><p>下载 <a href="https://github.com/XPoet/hexo-theme-ils/releases">主题最新 Release 版本</a> 。</p></li></ul><h2 id="How-to-use-如何使用"><a href="#How-to-use-如何使用" class="headerlink" title="How to use 如何使用"></a><a href="#How-to-use-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8" title="How to use 如何使用"></a>How to use 如何使用</h2><h3 id="Configuration-配置"><a href="#Configuration-配置" class="headerlink" title="Configuration 配置"></a><a href="#Configuration-%E9%85%8D%E7%BD%AE" title="Configuration 配置"></a>Configuration 配置</h3><p>主题的配置文件的详细说明，强烈建议多看几遍，并且对照着来修改自己的配置文件，边修改边查看页面效果。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207  </p><p># ————————————————————<br># Theme basic info (please don’t change)<br># 主题基本信息，请不要改动。<br># ————————————————————<br>theme_info:<br> name: ILS<br> version: 2.0.2<br> author: XPoet<br> repository: <a href="https://github.com/XPoet/hexo-theme-ils">https://github.com/XPoet/hexo-theme-ils</a>  </p><p># ————————————————————<br># Theme style settings<br># 主题样式设置<br># ————————————————————<br>style:<br> # Theme primary color<br> # 主题的主颜色，修改为自己喜欢的颜色即可，支持 rgb、十六进制格式。<br> primary_color: “#0066CC”  </p><p> # favicon<br> # 网站图标，把 “/source/images/“ 目录下的 “favicon.png”，换成自己的图片即可。<br> favicon: images/favicon.png  </p><p> # avatar<br> # 头像图片，把 “/source/images/“ 目录下的 “avatar.png”，换成自己的图片即可。<br> avatar: images/avatar.png  </p><p># ————————————————————<br># Navigation menu<br># 导航菜单<br># 如需新增导航页，请按下面格式填写，同时需要创建对应的 Hexo 页面。<br># 如何新增页面，请参考下面的教程：“Add page 添加页面”。<br># ————————————————————<br>menu:<br> Home: /<br> Archives: /archives<br> # Categories: /categories<br> # Tags: /tags<br> # Links: /links<br> # About: /about<br> # …  </p><p># ————————————————————<br># RSS<br># Dependencies: hexo-generator-feed<br># See: <a href="https://github.com/hexojs/hexo-generator-feed">https://github.com/hexojs/hexo-generator-feed</a><br># RSS 订阅，如需启用，请先安装 Hexo 插件：hexo-generator-feed。<br># 具体步骤，参考下面的教程：“RSS 订阅”。<br># ————————————————————<br>rss:<br> enable: false  </p><p># ————————————————————<br># Comment plugin<br># 评论插件<br># 主题内置了 Valine 和 Gitalk，只能使用其中一款。<br># ————————————————————<br>comments:<br> # Valine<br> # See: <a href="https://github.com/xCss/Valine">https://github.com/xCss/Valine</a><br> # 如何使用 Valine，请参考官方教程：<a href="https://github.com/xCss/Valine">https://github.com/xCss/Valine</a><br> # 获取必要的参数，在下面填写。<br> valine:<br> enable: false<br> appid:                # your leancloud application appid<br> appkey:               # your leancloud application appkey<br> meta:                 # comment input meta, type: Array, values: [‘nick’,’mail’,’link’]<br> placeholder:          # your placeholder  </p><p> # Gitalk<br> # See: <a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a><br> # 如何使用 Gitalk，请参考官方教程：<a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a><br> # 获取必要的参数，在下面填写。<br> gitalk:<br> enable: false<br> github_id:             # GitHub repo owner<br> repository:            # Repository name to store issues<br> client_id:             # GitHub Application Client ID<br> client_secret:         # GitHub Application Client Secret  </p><p># ————————————————————<br># Website count<br># 网站计数<br># ————————————————————<br>website_count:<br> # busuanzi<br> # See: <a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a><br> # 主题内置“不蒜子”计数，无需额外配置，选择你要开启的计数项即可。<br> # site_uv 访问人数计数<br> # site_pv 总访问量计数<br> # page_pv 文章阅读量计数<br> busuanzi_count:<br> enable: false<br> site_uv: false<br> site_pv: false<br> page_pv: false  </p><p># ————————————————————<br># Local Search<br># Dependencies: hexo-generator-searchdb<br># See: <a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a><br># 本地搜索，如需启用，请先安装 Hexo 插件：hexo-generator-searchdb。<br># 具体步骤，参考下面的教程：“Local search 本地搜索”。<br># ————————————————————<br>local_search:<br> enable: true  </p><p> # If auto, trigger search by changing input.<br> # If manual, trigger search by pressing enter key or search button.<br> # trigger 搜索触发方式，输入关键字后会触发搜索，可选 auto（自动）或 manual（手动）。<br> ### auto 每输入或删除一个字符后，自动触发搜索。<br> ### manual 每输入或删除一个字符后，需要按回车键触发搜索。<br> trigger: auto  # values: auto | manual  </p><p> # Unescape html strings to the readable one.<br> # # 转义 HTML 字符串为可读字符串。<br> unescape: false  </p><p> # Preload the search data when the page loads.<br> # 在页面加载时预加载搜索数据。<br> preload: false  </p><p># ————————————————————<br># Post word count<br># Dependencies: hexo-wordcount<br># See: <a href="https://github.com/willin/hexo-wordcount">https://github.com/willin/hexo-wordcount</a><br># 文章字数统计 &amp; 阅读时长统计<br># 如需启用，请先安装 Hexo 插件：hexo-wordcount。<br># 在博客根目录下使用 npm 命令安装: npm i hexo-wordcount –save<br># ————————————————————<br>post_wordcount:<br> enable: false<br> wordcount: false  # word count, one article<br> min2read: false   # time to read, one article  </p><p># ————————————————————<br># Home page article block display settings<br># 首页文章块底部的显示设置，可配置显示分类和标签。<br># limit 显示分类或标签的最大个数。<br># ————————————————————<br>home_article:<br> category:<br> enable: false     # show category in home page article block<br> limit: 3          # max number of categories shown in home page article block<br> tag:<br> enable: false     # show tags in home page article block<br> limit: 5          # max number of tags shown in home page article block  </p><p># ————————————————————<br># Code copy<br># 代码复制，代码块的复制风格可选 default | flat | mac。<br># ————————————————————<br>code_copy:<br> enable: true<br> style: flat        # values: default | flat | mac  </p><p># ————————————————————<br># Sidebar tools<br># 侧边栏工具（搜索按钮、昼夜模式切换按钮、RSS按钮、TOC显示切换按钮）<br># ————————————————————<br>side_tools:<br> enable: false  </p><p># ————————————————————<br># Back to top<br># 回到顶部<br># ————————————————————<br>back2top:<br> enable: false  </p><p># ————————————————————<br># Table of Contents in the Sidebar<br># 文章目录结构<br># ————————————————————<br>toc:<br> enable: false  </p><p> # Automatically add list number to toc.<br> # 给文章目录自动加上序号。<br> number: true  </p><p> # If true, all level of TOC in a post will be displayed, rather than the activated part of it.<br> # 是否展开所有目录。<br> expand_all: true  </p><p># ————————————————————<br># Magic<br># magic 启用后，主题将以简约的卡片形式显示。<br># 可分别配置缩放效果、阴影效果。<br># ————————————————————<br>magic:<br> enable: true<br> scale: false    # scale effect when the mouse hover<br> shadow: false   # shadow effect when the mouse hover  </p><h3 id="Comment-评论"><a href="#Comment-评论" class="headerlink" title="Comment 评论"></a><a href="#Comment-%E8%AF%84%E8%AE%BA" title="Comment 评论"></a>Comment 评论</h3><p>主题内置了 Valine 和 Gitalk 两款评论插件，你只能使用其他一款，如果两款评论插件的 enable 都设为了 true，将使用 Valine。</p><h4 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a><a href="#Valine" title="Valine"></a>Valine</h4><p>前往 <a href="https://github.com/xCss/Valine">https://github.com/xCss/Valine</a> 查看 Valine 如何使用，获取必要的参数，填写在配置文件里。</p><h4 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a><a href="#Gitalk" title="Gitalk"></a>Gitalk</h4><ol><li>在自己的 GitHub 账号下创建新的 OAuth App，链接：<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a> ，Homepage URL 和 Authorization callback URL 均填写自己的域名即可。</li><li>在自己的 GitHub 账号下创建新的 repository 并打开 Issues，用于存储评论内容。</li><li>把自己的 GitHub 用户名称、repository 名称 、OAuth App 的 Client ID 、Client Secret 分别填写在主题配置文件里。</li></ol><p>前往 <a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a> 查看 Gitalk 更多信息。</p><h3 id="Post-top-文章顶置"><a href="#Post-top-文章顶置" class="headerlink" title="Post top 文章顶置"></a><a href="#Post-top-%E6%96%87%E7%AB%A0%E9%A1%B6%E7%BD%AE" title="Post top 文章顶置"></a>Post top 文章顶置</h3><p>实现文章顶置功能，需在 Hexo 博客根目录下安装插件 **<code>hexo-generator-index-pin-top</code>**。</p><p>1  </p><p>npm install hexo-generator-index-pin-top  </p><p>然后在 <code>_posts</code> 文件夹里的需要顶置的文章页添加 <code>top</code> 属性，<strong>top</strong> 值越大，顶置文章越靠前，参考如下。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>-–<br>title: 千呼万唤始出来，Hexo 主题 ILS 正式发布<br>date: 2020-04-07 21:55:14<br>tags: [Hexo]<br>categories: [Hexo]<br>top: 9999<br>-–  </p><h3 id="Local-search-本地搜索"><a href="#Local-search-本地搜索" class="headerlink" title="Local search 本地搜索"></a><a href="#Local-search-%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2" title="Local search 本地搜索"></a>Local search 本地搜索</h3><ol><li><p>启用本地搜索功能，需在 Hexo 博客根目录下安装插件 **<code>hexo-generator-searchdb</code>**。</p><p>1  </p><p>npm install hexo-generator-searchdb  </p></li><li><p>在 Hexo 配置文件 <code>_config.yml</code> 增加如下配置。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p># Search<br>## <a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a><br>search:<br> path: search.json<br> field: post<br> content: true<br> format: striptags  </p></li><li><p>修改主题配置文件 <code>_config.yml</code>。</p><p>1<br>2<br>3<br>4<br>5  </p><p>local_search:<br> enable: true<br> trigger: auto # values: auto | manual<br> unescape: false<br> preload: true  </p></li></ol><h3 id="RSS-订阅"><a href="#RSS-订阅" class="headerlink" title="RSS 订阅"></a><a href="#RSS-%E8%AE%A2%E9%98%85" title="RSS 订阅"></a>RSS 订阅</h3><ol><li><p>启用 RSS 订阅功能，需先在 Hexo 博客根目录下安装插件 **<code>hexo-generator-feed</code>**。</p><p>1  </p><p>npm install hexo-generator-feed  </p></li><li><p>在 Hexo 配置文件 <code>_config.yml</code> 增加如下配置。</p><p>1<br>2<br>3<br>4<br>5<br>6  </p><p># Feed Atom<br># npm install hexo-generator-feed<br>feed:<br> type: atom<br> path: atom.xml<br> limit: 20  </p></li><li><p>修改主题配置文件 <code>_config.yml</code>。</p><p>1<br>2  </p><p>rss:<br> enable: true  </p></li></ol><h3 id="Add-page-添加页面"><a href="#Add-page-添加页面" class="headerlink" title="Add page 添加页面"></a><a href="#Add-page-%E6%B7%BB%E5%8A%A0%E9%A1%B5%E9%9D%A2" title="Add page 添加页面"></a>Add page 添加页面</h3><p><strong>Hexo 初始并没有 categories、about、links、tags 等页面，需要自己手动创建。</strong></p><p>以创建「关于」页面为例：</p><ol><li><p>在 Hexo 博客目录下执行命令，即可生成 <code>about</code> 文件夹。</p><p>1  </p><p>hexo new page about  </p></li><li><p>创建成功后，打开博客目录下 <code>/source/about/index.md</code> 文件，即可填写自己的内容。<br>支持 Markdown 和 HTML 格式；<code>comments: true</code> 表示该页面开启评论功能。</p><p>参考如下示例：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12  </p><p>-–<br>title: about<br>date: 2020-03-19 14:59:53<br>comments: true<br>-–  </p><p>## About me  </p><p>- XPoet「 X 诗人 」…<br> …<br> …<br> …  </p></li><li><p>在主题配置文件启用 <code>about</code> 导航菜单。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p># navigation menu<br>menu:<br> Home: /<br> Archives: /archives<br> # Category: /category<br> # Links: /links<br> About: /about<br> # …  </p></li></ol><p>其他页面的生成方式跟「关于」页面类似，此处不再赘述。</p><h2 id="Contribution-贡献"><a href="#Contribution-贡献" class="headerlink" title="Contribution 贡献"></a><a href="#Contribution-%E8%B4%A1%E7%8C%AE" title="Contribution 贡献"></a>Contribution 贡献</h2><p>欢迎各种形式的贡献，包括但不限于：美化样式、增加功能、改进代码、 修复 Bug 等。</p><h2 id="Feedback-反馈"><a href="#Feedback-反馈" class="headerlink" title="Feedback 反馈"></a><a href="#Feedback-%E5%8F%8D%E9%A6%88" title="Feedback 反馈"></a>Feedback 反馈</h2><p>在使用该主题过程中，如果遇到问题，请仔细阅读使用文档，或者给作者提 <code>Issue</code>。</p><h2 id="Licence-许可"><a href="#Licence-许可" class="headerlink" title="Licence 许可"></a><a href="#Licence-%E8%AE%B8%E5%8F%AF" title="Licence 许可"></a>Licence 许可</h2><p><a href="https://github.com/XPoet/hexo-theme-ils/blob/master/LICENSE">MIT</a> Copyright (c) 2020 XPoet</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fenix — 比 MyBatis 更加强大的 Spring Data JPA 扩展库</title>
      <link href="2019/08/20/fenix-bi-mybatis-geng-jia-qiang-da-de-spring-data-jpa-kuo-zhan-ku/"/>
      <url>2019/08/20/fenix-bi-mybatis-geng-jia-qiang-da-de-spring-data-jpa-kuo-zhan-ku/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><a href="https://github.com/blinkfox/fenix">Fenix</a>（菲尼克斯）是一个比 MyBatis 更加强大，为解决复杂、动态 SQL</p></blockquote><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> JPA </tag>
            
            <tag> Fenix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 使用 Navicat 连接 MySQL 数据库</title>
      <link href="2019/07/11/macos-shi-yong-navicat-lian-jie-mysql-shu-ju-ku/"/>
      <url>2019/07/11/macos-shi-yong-navicat-lian-jie-mysql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a><a href="#%E5%AE%89%E8%A3%85-MySQL" title="安装 MySQL"></a>安装 MySQL</h3><ul><li><p>从 MySQL 官网下载安装包进行安装，链接：</p><!-- more --><h3 id="安装-MySQL-1"><a href="#安装-MySQL-1" class="headerlink" title="安装 MySQL"></a><a href="#%E5%AE%89%E8%A3%85-MySQL" title="安装 MySQL"></a>安装 MySQL</h3></li><li><p>从 MySQL 官网下载安装包进行安装，链接：<a href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a></p></li><li><p>使用终端命令安装，需提前安装 Homebrew。</p><ol><li><p>安装 Homebrew</p><p>1  </p><p>/usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a>  </p></li><li><p>安装 MySQL</p><p>1  </p><p>brew install mysql  </p><h3 id="打开-MySQL-服务"><a href="#打开-MySQL-服务" class="headerlink" title="打开 MySQL 服务"></a><a href="#%E6%89%93%E5%BC%80-MySQL-%E6%9C%8D%E5%8A%A1" title="打开 MySQL 服务"></a>打开 MySQL 服务</h3></li></ol></li><li><p>在终端使用命令 <code>mysql --version</code> 查看 MySQL 版本，出现具体的版本号，表示 MySQL 成功安装，如下图。</p><p>1  </p><p>mysql –version  </p><p><img src="https://user-images.githubusercontent.com/24516169/61049925-52fd1980-a418-11e9-9558-7b4dee6c68b8.png" alt="mysql-version"></p></li><li><p>在终端使用命令 <code>bash mysql.server start</code> 来打开 MySQL 服务。如下图，表示 MySQL 服务启动成功。</p><p>1  </p><p>bash mysql.server start  </p><p><img src="https://user-images.githubusercontent.com/24516169/61096487-5a5d0b00-a48a-11e9-8715-7d3bb3a6d4da.png" alt="start-mysql"></p></li></ul><h3 id="登录-MySQL"><a href="#登录-MySQL" class="headerlink" title="登录 MySQL"></a><a href="#%E7%99%BB%E5%BD%95-MySQL" title="登录 MySQL"></a>登录 MySQL</h3><p>MySQL 默认的 root 账户不带密码，使用命令 <code>mysql -uroot</code> 可直接登录，如下图，表示登录成功。</p><p>1  </p><p>mysql -uroot  </p><p><img src="https://user-images.githubusercontent.com/24516169/61114682-6fa25b80-a4c3-11e9-899b-a3c9033da25e.png" alt="mysql-version"></p><p>因为默认的 root 账户不带密码，安全起见，我们给 root 账户设置密码。（例如设置密码：123456）</p><p>1  </p><p>set password for ‘root’@’localhost’=’123456’;  </p><p><img src="https://user-images.githubusercontent.com/24516169/61114990-11c24380-a4c4-11e9-9437-e56f6b406357.png" alt="mysql-modification-password"></p><p>密码设置成功后，再次登录时需要输入密码，如下命令。</p><p>1  </p><p>mysql -uroot -p’123456’  </p><p><img src="https://user-images.githubusercontent.com/24516169/78643782-637aeb80-78e7-11ea-9b17-4fa3ce8b1ba3.png" alt="mysql"></p><h3 id="Navicat-连接-MySQL"><a href="#Navicat-连接-MySQL" class="headerlink" title="Navicat 连接 MySQL"></a><a href="#Navicat-%E8%BF%9E%E6%8E%A5-MySQL" title="Navicat 连接 MySQL"></a>Navicat 连接 MySQL</h3><p>点击 Navicat Premium 左上角的”连接”，选择” MySQL “，新建一个 MySQL 连接，参数如下，默认端口 <strong>3306</strong>。<br><img src="https://user-images.githubusercontent.com/24516169/78645106-860e0400-78e9-11ea-9191-d7cd64447072.png" alt="mysql"></p><p>注：</p><ul><li><p>可使用命令 <code>lsof -i:3306</code> 查看 <strong>3306</strong> 端口是否被占用。</p></li><li><p>如果点击”<strong>测试连接</strong>“发现连接不上，出现报错信息：<br><code>2059 - Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded: dlopen(../Frameworks/caching_.......</code><br>错误原因是因为 MySQL 5.7 版本之后，默认验证方式由原来的 <strong>mysql_native_password</strong> 改成了 <strong>caching_sha2_password</strong>。只需把验证方式修改成原来的，就能连接上了。<br>修改方法：登录 MySQL，执行命令：</p><p>1  </p><p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> Navicat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular Material Dialog 拖拽功能的实现</title>
      <link href="2019/06/28/angular-material-dialog-tuo-zhuai-gong-neng-de-shi-xian/"/>
      <url>2019/06/28/angular-material-dialog-tuo-zhuai-gong-neng-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a><a href="#%E7%89%88%E6%9C%AC" title="版本"></a>版本</h4><p>本案例使用的 Angular 7.x 版本，Material 7.x 版本，但不限于此版本。</p><h4 id="新建Angular指令"><a href="#新建Angular指令" class="headerlink" title="新建Angular指令"></a><a href="#%E6%96%B0%E5%BB%BAAngular%E6%8C%87%E4%BB%A4" title="新建Angular指令"></a>新建Angular指令</h4><p>新建指令命令：<br><code>ng generate directive dialog-draggable</code></p><!-- more --><h4 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a><a href="#%E7%89%88%E6%9C%AC" title="版本"></a>版本</h4><p>本案例使用的 Angular 7.x 版本，Material 7.x 版本，但不限于此版本。</p><h4 id="新建Angular指令-1"><a href="#新建Angular指令-1" class="headerlink" title="新建Angular指令"></a><a href="#%E6%96%B0%E5%BB%BAAngular%E6%8C%87%E4%BB%A4" title="新建Angular指令"></a>新建Angular指令</h4><p>新建指令命令：<br><code>ng generate directive dialog-draggable</code></p><p>指令中拖拽功能代码实现：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80  </p><p>import { Directive, HostListener, OnInit } from ‘@angular/core’;<br>import { MatDialogContainer, MatDialogRef } from ‘@angular/material’;<br>import { Subscription, fromEvent } from ‘rxjs’;<br>import { takeUntil } from ‘rxjs/operators’;  </p><p>export interface Position {<br> x: number;<br> y: number;<br>}  </p><p>@Directive({<br> selector: ‘[dialog-draggable]‘<br>})<br>export class DialogDraggableDirective implements OnInit {  </p><p> private _subscription: Subscription;  </p><p> mouseStart: Position;  </p><p> mouseDelta: Position;  </p><p> offset: Position;  </p><p> constructor(<br> private matDialogRef: MatDialogRef&lt;any&gt;,<br> private container: MatDialogContainer<br> ) {<br> }  </p><p> ngOnInit() {<br> this.offset = this._getOffset();<br> this._updatePosition(this.offset.y, this.offset.x);<br> }  </p><p> @HostListener(‘mousedown’, [‘$event’])<br> onMouseDown(event: MouseEvent) {<br> this.mouseStart = { x: event.pageX, y: event.pageY };  </p><p> const mouseup$ = fromEvent(document, ‘mouseup’);<br> this._subscription = mouseup$.subscribe(() =&gt; this.onMouseup());  </p><p> const mousemove$ = fromEvent(document, ‘mousemove’)<br> .pipe(takeUntil(mouseup$))<br> .subscribe((e: MouseEvent) =&gt; this.onMouseMove(e));  </p><p> this._subscription.add(mousemove$);<br> }  </p><p> onMouseMove(event: MouseEvent) {<br> this.mouseDelta = { x: (event.pageX - this.mouseStart.x), y: (event.pageY - this.mouseStart.y) };  </p><p> this._updatePosition(this.offset.y + this.mouseDelta.y, this.offset.x + this.mouseDelta.x);<br> }  </p><p> onMouseup() {<br> if (this._subscription) {<br> this._subscription.unsubscribe();<br> this._subscription = undefined;<br> }<br> if (this.mouseDelta) {<br> this.offset.x += this.mouseDelta.x;<br> this.offset.y += this.mouseDelta.y;<br> }<br> }  </p><p> private _updatePosition(top: number, left: number) {<br> this.matDialogRef.updatePosition({<br> top: top + ‘px’,<br> left: left + ‘px’<br> });<br> }  </p><p> private _getOffset(): Position {<br> const box = this.container[‘_elementRef’].nativeElement.getBoundingClientRect();<br> return {<br> x: box.left + pageXOffset,<br> y: box.top + pageYOffset<br> };<br> }<br>}  </p><p>在全局的CSS样式文件添加下面的CSS代码：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>[dialog-draggable] {<br> margin: -24px -24px 20px -24px !important;<br> padding: 10px 24px;<br> background: #283593 !important;<br> color: #fff;<br> cursor: move;<br>}  </p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8" title="如何使用"></a>如何使用</h4><p>在Dialog组件中使用dialog-draggable指令即可实现窗口拖拽，如下</p><p>1<br>2<br>3  </p><h2 mat-dialog-title dialog-draggable\>   Angular Material Dialog Draggable  </h2\>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
            <tag> Material </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码性能评估库Stalker介绍</title>
      <link href="2019/02/14/java-dai-ma-xing-neng-ping-gu-ku-stalker-jie-shao/"/>
      <url>2019/02/14/java-dai-ma-xing-neng-ping-gu-ku-stalker-jie-shao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/blinkfox/stalker/blob/master/README.md">English</a></p><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个极简的 Java ASCII 表格生成库</title>
      <link href="2019/01/25/yi-ge-ji-jian-de-java-ascii-biao-ge-sheng-cheng-ku/"/>
      <url>2019/01/25/yi-ge-ji-jian-de-java-ascii-biao-ge-sheng-cheng-ku/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个轻量级、零依赖的 Java ASCII 表格生成库。</p></blockquote><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之桥接模式</title>
      <link href="2018/12/19/java-mian-xiang-dui-xiang-she-ji-zhi-qiao-jie-mo-shi/"/>
      <url>2018/12/19/java-mian-xiang-dui-xiang-she-ji-zhi-qiao-jie-mo-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 软件设计 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之适配器模式</title>
      <link href="2018/12/12/java-mian-xiang-dui-xiang-she-ji-zhi-gua-pei-qi-mo-shi/"/>
      <url>2018/12/12/java-mian-xiang-dui-xiang-she-ji-zhi-gua-pei-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 软件设计 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则</title>
      <link href="2018/11/24/ruan-jian-cheng-xu-she-ji-yuan-ze/"/>
      <url>2018/11/24/ruan-jian-cheng-xu-she-ji-yuan-ze/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 软件设计 </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab CI/CD 介绍和使用</title>
      <link href="2018/11/22/gitlab-ci-cd-jie-shao-he-shi-yong/"/>
      <url>2018/11/22/gitlab-ci-cd-jie-shao-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
            <tag> GitLab CI </tag>
            
            <tag> DevOps </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用时间戳和随机数生成一个不重复的字符串</title>
      <link href="2018/11/21/li-yong-shi-jian-chuo-he-sui-ji-shu-sheng-cheng-yi-ge-bu-chong-fu-de-zi-fu-chuan/"/>
      <url>2018/11/21/li-yong-shi-jian-chuo-he-sui-ji-shu-sheng-cheng-yi-ge-bu-chong-fu-de-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 或 TypeScript 巧妙利用时间戳和随机数生成一个不重复的字符串，可作为 UUID 使用，此方法非常简单高效。</p><!-- more --><p>JavaScript 或 TypeScript 巧妙利用时间戳和随机数生成一个不重复的字符串，可作为 UUID 使用，此方法非常简单高效。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>/**<br> * JavaScript 版本<br> * @param randomLength 截取随机数的长度<br> * @return String 不重复的字符串（uuid）<br> */<br>export const getUuid = (randomLength) =&gt; {<br> return Number(Math.random().toString().substr(2, randomLength) + Date.now()).toString(36);<br>};  </p><p>// getUuid(5) -&gt; 2l5w9z6sqvg0  </p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>/**<br> * TypeScript 版本<br> * @param randomLength{number} 截取随机数的长度<br> * @return {string} 不重复的字符串（uuid）<br> */<br>export const getUuid = (randomLength: number = 5): string =&gt; {<br> return Number(Math.random().toString().substr(2, randomLength) + Date.now()).toString(36);<br>};  </p><p>// getUuid(5) -&gt; 2l5w9z6sqvg0</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> TS </tag>
            
            <tag> UUID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 文档风格的 Typora 主题</title>
      <link href="2018/11/19/vue-wen-dang-feng-ge-de-typora-zhu-ti/"/>
      <url>2018/11/19/vue-wen-dang-feng-ge-de-typora-zhu-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><a href="https://github.com/blinkfox/typora-vue-theme">typora-vue-theme</a> 是 Typora</p></blockquote><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU多级缓存</title>
      <link href="2018/11/18/cpu-duo-ji-huan-cun/"/>
      <url>2018/11/18/cpu-duo-ji-huan-cun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、什么是CPU缓存"><a href="#一、什么是CPU缓存" class="headerlink" title="一、什么是CPU缓存"></a><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFCPU%E7%BC%93%E5%AD%98" title="一、什么是CPU缓存"></a>一、什么是CPU缓存</h2><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
            <tag> CPU缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试指南</title>
      <link href="2018/11/15/dan-yuan-ce-shi-zhi-nan/"/>
      <url>2018/11/15/dan-yuan-ce-shi-zhi-nan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用(二)</title>
      <link href="2018/11/14/java8-xin-te-xing-ji-shi-yong-er/"/>
      <url>2018/11/14/java8-xin-te-xing-ji-shi-yong-er/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a><a href="#%E6%89%A9%E5%B1%95%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%94%AF%E6%8C%81" title="扩展注解的支持"></a>扩展注解的支持</h2><p>Java</p><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用(一)</title>
      <link href="2018/11/13/java8-xin-te-xing-ji-shi-yong-yi/"/>
      <url>2018/11/13/java8-xin-te-xing-ji-shi-yong-yi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a><a href="#%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考</p><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java7新特性及使用</title>
      <link href="2018/11/12/java7-xin-te-xing-ji-shi-yong/"/>
      <url>2018/11/12/java7-xin-te-xing-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a><a href="#%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8" title="新特性列表"></a>新特性列表</h2><p>以下是Java7中的引入的部分新特性。关于Java7更详细的介绍可参考</p><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java6新特性及使用</title>
      <link href="2018/11/11/java6-xin-te-xing-ji-shi-yong/"/>
      <url>2018/11/11/java6-xin-te-xing-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a><a href="#%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8" title="新特性列表"></a>新特性列表</h2><p>以下是Java6中的引入的部分新特性，相比Java5的新特性就少了很多了。关于Java6更详细的介绍可参考</p><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java5新特性及使用</title>
      <link href="2018/11/09/java5-xin-te-xing-ji-shi-yong/"/>
      <url>2018/11/09/java5-xin-te-xing-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a><a href="#%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8" title="新特性列表"></a>新特性列表</h2><p>以下是Java5中的引入的部分新特性，关于更详细的新特性了解，可参考</p><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解的理解和应用</title>
      <link href="2018/11/08/java-zhu-jie-de-li-jie-he-ying-yong/"/>
      <url>2018/11/08/java-zhu-jie-de-li-jie-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><a href="#%E6%A6%82%E8%BF%B0" title="概述"></a>概述</h2><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射基础</title>
      <link href="2018/11/07/java-fan-she-ji-chu/"/>
      <url>2018/11/07/java-fan-she-ji-chu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" title="一、概述"></a>一、概述</h2><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO 知识整理</title>
      <link href="2018/11/05/java-io-zhi-shi-zheng-li/"/>
      <url>2018/11/05/java-io-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="各IO类关系梳理"><a href="#各IO类关系梳理" class="headerlink" title="各IO类关系梳理"></a><a href="#%E5%90%84IO%E7%B1%BB%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86" title="各IO类关系梳理"></a>各IO类关系梳理</h2><ul><li>InputStream: Java<!-- more --></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之责任链模式</title>
      <link href="2018/11/04/java-mian-xiang-dui-xiang-she-ji-zhi-ze-ren-lian-mo-shi/"/>
      <url>2018/11/04/java-mian-xiang-dui-xiang-she-ji-zhi-ze-ren-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- more -->]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 软件设计 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 配置多个 Git 账户的 SSH-Key</title>
      <link href="2018/07/16/macos-pei-zhi-duo-ge-git-zhang-hu-de-ssh-key/"/>
      <url>2018/07/16/macos-pei-zhi-duo-ge-git-zhang-hu-de-ssh-key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="准备工作"></a>准备工作</h4><p>请确保在你的Mac上已安装Git。安装Git请参考：</p><!-- more --><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="准备工作"></a>准备工作</h4><p>请确保在你的Mac上已安装Git。安装Git请参考：<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">传送门</a><br>在终端输入命令<code>$ git --version</code>， 能打印出具体的版本号，表示Git正确安装。</p><h4 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a><a href="#%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE" title="开始配置"></a>开始配置</h4><p>本文以配置<strong>GitHub</strong>和<strong>GitLab</strong>为案例，将生成两对公共/私有rsa密钥对，<strong>rsa_github</strong> 和 <strong>rsa_gitlab</strong>。</p><h5 id="在本地创建SSH-Key"><a href="#在本地创建SSH-Key" class="headerlink" title="在本地创建SSH-Key"></a><a href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BASSH-Key" title="在本地创建SSH-Key"></a>在本地创建SSH-Key</h5><p>1、打开终端，<code>$ cd ~</code>，进入到当前用户目录下。</p><p>2、使用命令<code>$ ssh-keygen -t rsa -C &quot;i@itpoet.cn&quot;</code>生成公共/私有rsa密钥对。此时会看到终端提示输入要保存密钥的文件名，为了做区分，我们给文件名加个后缀，本例第一个rsa密钥对：<strong>rsa_github</strong>。<br>接着会看到终端提示输入密码，敲两次 <em><strong>Enter回车键</strong></em> 则不需要密码。最终在 <em><strong>.ssh 文件夹</strong></em> 里生成 <em><strong>rsa_github</strong></em> 和 <em><strong>rsa_github.pub</strong></em> 两个文件，如图：<br><img src="https://user-images.githubusercontent.com/24516169/43447613-6a4544ae-94de-11e8-8e91-07d6ef1e45e3.png" alt="生成rsa_github"><br><img src="https://user-images.githubusercontent.com/24516169/43447618-6add7116-94de-11e8-9986-8b90bf50e098.png" alt="rsa_github和rsa_github.pub密钥对"><br><strong>注意</strong>：在 <strong>第2步</strong> 执行完后，如果用户目录下没有生成 <em><strong>.ssh 文件夹</strong></em> ，那我们需要手动创建。</p><p>1<br>2<br>3  </p><p>$ cd ~<br>$ mkdir .ssh<br>$ cd .ssh  </p><p>成功创建完 <em><strong>.ssh 文件夹</strong></em> 之后，再执行 <strong>第2步</strong> 操作。</p><p>3、创建本例的第二个rsa密钥对，<strong>rsa_gitlab</strong>。</p><p>1<br>2  </p><p>$ cd .ssh<br>$ ssh-keygen -t rsa -C “<a href="mailto:&#x61;&#64;&#105;&#x74;&#x70;&#x6f;&#101;&#116;&#46;&#x63;&#x6e;">&#x61;&#64;&#105;&#x74;&#x70;&#x6f;&#101;&#116;&#46;&#x63;&#x6e;</a>“  </p><p>如图：<br><img src="https://user-images.githubusercontent.com/24516169/43447615-6a959e4a-94de-11e8-8f23-8fd2128ba6a7.png" alt="生成rsa_github"><br><img src="https://user-images.githubusercontent.com/24516169/43447619-6b104b72-94de-11e8-9a4b-4febc6458e4c.png" alt="rsa_github和rsa_github.pub密钥对"></p><p>4、为ssh添加config配置文件，在 <em><strong>.ssh文件夹</strong></em> 下，新建config文件。</p><p>1<br>2  </p><p>$ cd ~/.ssh<br>$ touch config  </p><p>config文件创建好之后，将其内容修改为：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>Host github.com<br> User itPoet_github<br> IdentityFile ~/.ssh/rsa_github  </p><p>Host gitlab.com<br> User itPoet_gitlab<br> IdentityFile ~/.ssh/rsa_gitlab  </p><p>5、配置 <strong>.gitconfig</strong> 文件。使用如下命令将会在用户目录下自动创建 <strong>.gitconfig</strong> 文件。</p><p>1<br>2<br>3  </p><p>$ cd ~<br>$ git config –global user.name “itPoet_github”<br>$ git config –global user.email “<a href="mailto:&#105;&#64;&#105;&#x74;&#x70;&#x6f;&#101;&#116;&#46;&#99;&#x6e;">&#105;&#64;&#105;&#x74;&#x70;&#x6f;&#101;&#116;&#46;&#99;&#x6e;</a>“  </p><p><strong>注意</strong>：在 <strong>第4步</strong> 执行完后，如果用户目录下没有生成 <em><strong>.gitconfig</strong></em> 文件 ，那我们需要手动创建。</p><p>1<br>2  </p><p>$ cd ~<br>$ touch .gitconfig  </p><p>最后将.gitconfig文件的内容修改为：</p><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>[user]<br> name = itPoet_github<br> email = <a href="mailto:&#x69;&#64;&#x69;&#x74;&#112;&#x6f;&#101;&#x74;&#46;&#x63;&#110;">&#x69;&#64;&#x69;&#x74;&#112;&#x6f;&#101;&#x74;&#46;&#x63;&#110;</a><br>[user]<br> name = itPoet_gitlab<br> email = <a href="mailto:&#x61;&#64;&#105;&#116;&#112;&#x6f;&#101;&#x74;&#46;&#99;&#x6e;">&#x61;&#64;&#105;&#116;&#112;&#x6f;&#101;&#x74;&#46;&#99;&#x6e;</a>  </p><h5 id="在对应的Git网站添加SSH密钥设置"><a href="#在对应的Git网站添加SSH密钥设置" class="headerlink" title="在对应的Git网站添加SSH密钥设置"></a><a href="#%E5%9C%A8%E5%AF%B9%E5%BA%94%E7%9A%84Git%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5%E8%AE%BE%E7%BD%AE" title="在对应的Git网站添加SSH密钥设置"></a>在对应的Git网站添加SSH密钥设置</h5><p>1、 <strong>GitHub</strong><br>settings –&gt; SSH and GPG keys –&gt; New SSH Key<br>打开 <strong>rsa_github.pub</strong>，将里面的内容复制到 <strong>Key</strong> 输入框中，如图：<br>如图：<br><img src="https://user-images.githubusercontent.com/24516169/43447624-6c25549e-94de-11e8-9584-527e2100964c.png" alt="github.com-add-new-ssh-key-1"><br><img src="https://user-images.githubusercontent.com/24516169/43447626-6c56a026-94de-11e8-9530-3ba0accc6a86.png" alt="github.com-add-new-ssh-key-2"></p><p>2、 <strong>GitLab</strong><br>Profile –&gt; SSH keys<br>打开 <strong>rsa_gitlab.pub</strong>，将里面的内容复制到 <strong>Key</strong> 输入框中，如图：<br>如图：<br><img src="https://user-images.githubusercontent.com/24516169/43447628-6ca0b468-94de-11e8-95e5-377c7b85b97c.png" alt="gitlab.com-add-new-ssh-key-1"><br><img src="https://user-images.githubusercontent.com/24516169/43447626-6c56a026-94de-11e8-9530-3ba0accc6a86.png" alt="gitlab.com-add-new-ssh-key-2"></p><p><strong>至此，在Mac下配置多个Git账户的SSH-Key参考教程也完成，同理，我们还可以配置Coding、码云等。现在让我们来体验使用SSH提交代码吧~~</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术教程 </tag>
            
            <tag> Mac </tag>
            
            <tag> Git </tag>
            
            <tag> SSH-Key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，也许就是再也不见</title>
      <link href="2018/04/21/zai-jian-ye-xu-jiu-shi-zai-ye-bu-jian/"/>
      <url>2018/04/21/zai-jian-ye-xu-jiu-shi-zai-ye-bu-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
        <tags>
            
            <tag> 散文集 </tag>
            
            <tag> 散文 </tag>
            
            <tag> 再见 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不朽的失眠</title>
      <link href="2018/03/20/bu-xiu-de-shi-mian/"/>
      <url>2018/03/20/bu-xiu-de-shi-mian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>记得第一次见这篇文章出现在初中的语文书上，确确实实引起了我的共鸣，自此念念不忘，忽然感觉此刻很应景，收录此文。</p></blockquote><p>他落榜了！一千二百年前。榜纸那么大那么长，然而，就是没有他的名字。啊！竟单单容不下他的名字“张</p><!-- more --><blockquote><p>记得第一次见这篇文章出现在初中的语文书上，确确实实引起了我的共鸣，自此念念不忘，忽然感觉此刻很应景，收录此文。</p></blockquote><p>他落榜了！一千二百年前。榜纸那么大那么长，然而，就是没有他的名字。啊！竟单单容不下他的名字“张继”那两个字。</p><p>考中的人，姓名一笔一划写在榜单上，天下皆知。奇怪的是，在他的感觉里，考不上，才更是天下皆知，这件事，令他羞惭沮丧。</p><p>离开京城吧！议好了价，他踏上小舟。本来预期的情节不是这样的，本来也许有插花游街、马蹄轻疾的风流，有衣锦还乡、袍笏加身的荣耀。然而，寒窗十年，虽有他的悬梁刺股，琼林宴上，却并没有他的一角席次。</p><p>船行似风。</p><p>江枫如火，在岸上举着冷冷的爝焰，这天黄昏，船，来到了苏州。但，这美丽的古城，对张继而言，也无非是另一个触动愁情的地方。</p><p>如果说白天有什么该做的事，对一个读书人而言，就是读书吧！夜晚呢？夜晚该睡觉以便养足精神第二天再读。然而，今夜是一个忧伤的夜晚。今夜，在异乡，在江畔，在秋冷雁高的季节，容许一个落魄的士子放肆他的忧伤。江水，可以无限度地收纳古往今来一切不顺遂之人的泪水。</p><p>这样的夜晚，残酷地坐着，亲自听自己的心正被什么东西啮食而一分一分消失的声音。并且眼睁睁地看自己的生命如劲风中的残灯，所有的力气都花在抗拒，油快尽了，微火每一刹那都可能熄灭。然而，可恨的是，终其一生，它都不曾华美灿烂过啊！</p><p>江水睡了，船睡了，船家睡了，岸上的人也睡了。惟有他，张继，睡不着。夜愈深，愈清醒，清醒如败叶落余的枯树，似梁燕飞去的空巢。</p><p>起先，是睡眠排拒的他。(也罢，这半生，不是处处都遭排拒吗？)而后，是他在赌气，好，无眠就无眠，长夜独醒，就干脆彻底来为自已验伤，有何不可？</p><p>月亮西斜了，一副意兴阑珊的样子。有乌啼，粗嗄嘶哑，是乌鸦。那月亮被它一声声叫得更黯淡了。江岸上，想已霜结千草。夜空里，星子亦如清霜，一粒粒零落凄绝。</p><p>在须角在眉梢，他感觉，似乎也森然生凉，那阴阴不怀好意的凉气啊，正等待凝成早秋的霜花，来贴缀他惨淡少年的容颜。</p><p>江上渔火二三，他们在干什么？在捕鱼吧？或者，虾？他们也会有撒空网的时候吗？世路艰辛啊！即使潇洒的捕鱼的，也不免投身在风波里吧？然而，能辛苦工作，也是一种幸福吧！今夜，月自光其光，霜自冷其冷，安心的人在安眠，工作的人去工作。只有我张继，是天不管地不收的一个，是既没有权利去工作，也没福气去睡眠的一个……</p><p>钟声响了，这奇怪的深夜的寒山寺钟声。一般寺庙，都是暮鼓晨钟，寒山寺庙敲“夜半钟”，用以惊世。钟声贴着水面传来，在别人，那声音只是睡梦中模糊的衬底音乐。在他，却一记一记都撞击在心坎上，正中要害。钟声那么美丽，但钟声自己到底是痛还是不痛呢？既然失眠，他推枕而起，摸黑写下“枫桥夜泊”四字。然后，就把其余二十八字照抄下来。我说“照抄”，是因为那二十八个字在他心底已像白墙上的黑字一样分明凸显：</p><p><strong>月落乌啼霜满天，江枫渔火对愁眠。</strong></p><p><strong>姑苏城外寒山寺，夜半钟声到客船。</strong></p><p>感谢上苍，如果没有落第的张继，诗的历史上便少了一首好诗，我们的某一种心情，就没有人来为我们一语道破。</p><p>一千二百年过去了，那张长长的榜单上（就是张继挤不进去的那纸金榜）曾经出现过的状元是谁？哈！管他是谁。真正被记得的名字是“落第者张继”。有人会记得那一届状元披红游街的盛景吗？不！我们只记得秋夜的客船上那个失意的人，以及他那场不朽的失眠。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文章收录 </tag>
            
            <tag> 枫桥夜泊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Node.js搭建Socket聊天室</title>
      <link href="2018/02/07/ji-yu-node-js-da-jian-socket-liao-tian-shi/"/>
      <url>2018/02/07/ji-yu-node-js-da-jian-socket-liao-tian-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#%E5%89%8D%E8%A8%80" title="前言"></a>前言</h5><p>可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多</p><!-- more --><h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a><a href="#%E5%89%8D%E8%A8%80" title="前言"></a>前言</h5><p>可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多依靠传统服务器端编程语言才能实现的事，甚至更加简便、更加高效。<br>本案例使用Node.js的net模块，建立服务端与客户端的Socket连接，简单实现了客户端广播消息通信和点对点通信。</p><h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" title="项目结构"></a>项目结构</h5><h6 id="server-js-服务端"><a href="#server-js-服务端" class="headerlink" title="server.js 服务端"></a><a href="#server-js-%E6%9C%8D%E5%8A%A1%E7%AB%AF" title="server.js 服务端"></a>server.js 服务端</h6><p>项目下的server.js是服务端的执行文件，用于创建服务端的Socket服务，监听指定端口；接收客户端传过来的数据，解析数据并按照数据中附带的协议进行广播消息通信或点对点通信。<br><strong>具体代码如下：</strong></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127  </p><p>// Socket聊天室 - server 服务端<br>const net = require(‘net’);  </p><p>// 定义clients（键值对集合），用于存储所有的客户端连接，通过用户名去索引客户端socket<br>let clients = {};  </p><p>let server = net.createServer((socket) =&gt; {  </p><p> // 客户端登入<br> function signin(clientDataContent) {<br> clientDataContent = JSON.parse(clientDataContent);<br> let username = clientDataContent.from;  </p><p> // 如果clients（客户端 socket 集合）中有1个以上的成员，就广播通知所有人谁谁上线了，除了他本身<br> if (Object.keys(clients).length) {<br> let onlineNotice = {  // 组成上线通知消息数据格式<br> protocol: ‘online’,<br> online: username,<br> onlineCount: Object.keys(clients).length + 1<br> };<br> // 遍历 clients ，给除了自身的所有客户端发送消息<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let noticeClient = clients[username];<br> noticeClient.write(JSON.stringify(onlineNotice));<br> }<br> }<br> }  </p><p> // 将新连接的客户端socket存储于clients<br> clients[username] = socket;  </p><p> // 服务端打印上线提示消息<br> console.log(`欢迎 ${socket.remoteAddress}:${socket.remotePort}【${username}】，加入聊天室，当前在线：${Object.keys(clients).length}`);<br> }  </p><p> // 广播消息通信<br> function broadcast(clientDataContent) {<br> // 广播出去消息数据格式 json<br> let sendClientData = JSON.parse(clientDataContent);  </p><p> // 遍历clients对象（for in），给所有的客户端socket广播消息<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let client = clients[username];<br> client.write(JSON.stringify(sendClientData));<br> }<br> }<br> }  </p><p> // p2p 点对点通信<br> function p2p(clientDataContent) {<br> let p2pClientData = JSON.parse(clientDataContent);<br> // 给指定的客户端发送消息<br> clients[p2pClientData.to].write(JSON.stringify(p2pClientData));<br> }  </p><p> // 给每一个连接服务端的客户端socket注册data事件<br> socket.on(‘data’, (chunk) =&gt; {<br> try {<br> // 对客户端传过来的数据chunk（json数据）进行序列化<br> let clientDataContent = chunk.toString().trim();  </p><p> // 获取协议<br> let protocol = JSON.parse(clientDataContent).protocol;<br> switch (protocol) {<br> case ‘signin’:<br> signin(clientDataContent);<br> break;<br> case ‘broadcast’:<br> broadcast(clientDataContent);<br> break;<br> case ‘p2p’:<br> p2p(clientDataContent);<br> break;<br> default:<br> socket.write(‘错误！未能识别的通信协议！’);<br> break;<br> }<br> } catch (error) {<br> socket.write(‘出现错误了哦~’);<br> throw error;<br> }<br> });  </p><p> // 给每一个连接服务端的客户端socket注册error事件，如果连接中断，则触发此事件<br> socket.on(‘error’, (error) =&gt; {<br> // 在客户端对象中，将连接中断的那个客户端删除<br> let deletekey = null;  </p><p> // 遍历clients对象，找到下线的socket，并将其删除<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let client = clients[username];<br> if (socket === client) deletekey = username;<br> }<br> }<br> delete clients[deletekey];  </p><p> // 广播通知所有人，谁谁下线了<br> let offlineNotice = {  // 组成下线通知消息数据格式<br> protocol: ‘offline’,<br> offline: deletekey,<br> onlineCount: Object.keys(clients).length<br> };<br> for (let username in clients) {<br> if (clients.hasOwnProperty(username)) {<br> let noticeClient = clients[username];<br> noticeClient.write(JSON.stringify(offlineNotice));<br> }<br> }  </p><p> // server 消息<br> console.log(`${deletekey} 下线了，当前在线：${Object.keys(clients).length}`);<br> });<br>});  </p><p>// 监听指定端口<br>let port = 2018;<br>server.listen(port, (error) =&gt; {<br> if (error) {<br> console.log(`${port}端口被占用！`);<br> } else {<br> console.log(`服务器端正常启动，正在监听${port}端口`);<br> }<br>});  </p><h6 id="client-js-客户端"><a href="#client-js-客户端" class="headerlink" title="client.js 客户端"></a><a href="#client-js-%E5%AE%A2%E6%88%B7%E7%AB%AF" title="client.js 客户端"></a>client.js 客户端</h6><p>项目下的client.js是客户端的执行文件，用于创建客户端的Socket服务。将用户输入的内容按特定的格式组成数据结构发给服务端，同时打印出服务端指定的内容。<br><strong>具体代码如下：</strong></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98  </p><p>// Socket聊天室 - 客户端 client<br>const net = require(‘net’);<br>const readline = require(‘readline’);<br>const rl = readline.createInterface(process.stdin, process.stdout);  </p><p>rl.question(‘请输入聊天昵称：’, (nickname) =&gt; {<br> nickname = nickname.trim();<br> if (!nickname) {<br> throw new Error(‘昵称不能为空！’);<br> }  </p><p> // 创建与服务端的连接<br> // 设置正确的服务端的ip地址和端口<br> let server = net.connect({port: 2018, host: ‘127.0.0.1’}, () =&gt; {  </p><p> // 登入操作<br> let user = {<br> protocol: ‘signin’,<br> from: nickname<br> };  </p><p> // 往服务端传送数据<br> server.write(JSON.stringify(user));<br> console.log(`【系统通知】已成功加入聊天室，尽情畅聊吧~`);  </p><p> // 监听服务端发送过来的数据<br> server.on(‘data’, (chunk) =&gt; {<br> try {<br> let serverDataContent = JSON.parse(chunk.toString().trim());<br> let protocol = serverDataContent.protocol;<br> switch (protocol) {<br> case ‘online’:<br> console.log(`\n【系统通知】欢迎：${serverDataContent.online}，加入聊天室，当前在线人数：${serverDataContent.onlineCount}\n`);<br> rl.prompt();<br> break;<br> case ‘offline’:<br> console.log(`\n【系统通知】${serverDataContent.offline}下线了，当前在线人数：${serverDataContent.onlineCount}\n`);<br> rl.prompt();<br> break;<br> case ‘broadcast’:<br> console.log(`\n[@所有人] ${serverDataContent.from}&gt; ${serverDataContent.message}\n`);<br> rl.prompt();<br> break;<br> case ‘p2p’:<br> console.log(`\n[@${serverDataContent.to}] ${serverDataContent.from}&gt; ${serverDataContent.message}\n`);<br> rl.prompt();<br> break;<br> default:<br> server.write(‘错误！未能识别的通信协议！’);<br> break;<br> }<br> } catch (error) {<br> server.write(‘出现错误了哦~’);<br> throw error;<br> }  </p><p> });  </p><p> rl.setPrompt(nickname + ‘&gt; ‘);  // 此时没有写入控制台<br> rl.prompt(); // 写入控制台  </p><p> // 输入一行内容敲回车<br> rl.on(‘line’, (line) =&gt; {<br> line = line.toString().trim();  </p><p> // 内容： user1:我只跟你说话  表示，客户端用户只跟user1通信<br> // 根据客户端用户输入的内容按“:”分割成两部分<br> let arrString = line.split(‘:’);<br> let sendServerData = null;  </p><p> // 组成往服务端发送的数据格式<br> if (arrString.length === 2) {<br> // 点对点<br> sendServerData = {<br> protocol: ‘p2p’,<br> from: nickname,<br> to: arrString[0],<br> message: arrString[1]<br> };<br> } else {<br> // 广播消息<br> sendServerData = {<br> protocol: ‘broadcast’,<br> from: nickname,<br> message: line<br> };<br> }  </p><p> // 往服务端发送数据<br> server.write(JSON.stringify(sendServerData));<br> rl.prompt(); // 写入控制台<br> });  </p><p> rl.on(‘close’, () =&gt; {  </p><p> });<br> });<br>});  </p><h5 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a><a href="#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD" title="实现功能"></a>实现功能</h5><p>目前已实现：客户端广播消息通信、点对点通信。</p><h5 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a><a href="#%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8" title="项目使用"></a>项目使用</h5><ol><li>启动服务端，<code>$ node server.js</code><br><img src="https://user-images.githubusercontent.com/24516169/36706538-325fc724-1ba5-11e8-8596-08b28f52ecc2.jpg" alt="启动服务端"></li><li>启动第一个客户端，<code>$ node client.js</code><br><img src="https://user-images.githubusercontent.com/24516169/36706534-27154c7c-1ba5-11e8-8c36-f0478296563d.jpg" alt="启动客户端"></li><li>启动第二个客户端，<code>$ node client.js</code></li><li>……</li></ol><h5 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a><a href="#%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91" title="演示视频"></a>演示视频</h5><p><img src="https://user-images.githubusercontent.com/24516169/36706486-f24b8e48-1ba4-11e8-8627-f236d924330d.gif" alt="Demo演示gif"></p><h5 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD" title="项目下载"></a>项目下载</h5><p>本案例源代码托管于GitHub，下载：<a href="https://github.com/XPoet/node.js-chartroom">传送门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 元素垂直居中的几种常用方法</title>
      <link href="2018/02/02/css-yuan-su-chui-zhi-ju-zhong-de-ji-chong-chang-yong-fang-fa/"/>
      <url>2018/02/02/css-yuan-su-chui-zhi-ju-zhong-de-ji-chong-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a><a href="#%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8" title="子绝父相"></a>子绝父相</h3><p>子绝父相：子元素绝对定位，父元素相对定位。</p><!-- more --><h3 id="子绝父相-1"><a href="#子绝父相-1" class="headerlink" title="子绝父相"></a><a href="#%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8" title="子绝父相"></a>子绝父相</h3><p>子绝父相：子元素绝对定位，父元素相对定位。</p><h4 id="不知道子元素高度和父元素高度的情况"><a href="#不知道子元素高度和父元素高度的情况" class="headerlink" title="不知道子元素高度和父元素高度的情况"></a><a href="#%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AD%90%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6%E5%92%8C%E7%88%B6%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6%E7%9A%84%E6%83%85%E5%86%B5" title="不知道子元素高度和父元素高度的情况"></a>不知道子元素高度和父元素高度的情况</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>.parentElement {<br> position: relative;<br>}  </p><p>.childElement {<br> position: absolute;<br> top: 50%;<br> transform: translateY(-50%);<br>}  </p><h4 id="知道子元素高度和父元素高度的情况"><a href="#知道子元素高度和父元素高度的情况" class="headerlink" title="知道子元素高度和父元素高度的情况"></a><a href="#%E7%9F%A5%E9%81%93%E5%AD%90%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6%E5%92%8C%E7%88%B6%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6%E7%9A%84%E6%83%85%E5%86%B5" title="知道子元素高度和父元素高度的情况"></a>知道子元素高度和父元素高度的情况</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12  </p><p>.parentElement {<br> position: relative;<br>}  </p><p>.childElement {<br> position: absolute;<br> top: 0;<br> bottom: 0;<br> left: 0;<br> right: 0;<br> margin: auto;<br>}  </p><h3 id="子元素相对定位"><a href="#子元素相对定位" class="headerlink" title="子元素相对定位"></a><a href="#%E5%AD%90%E5%85%83%E7%B4%A0%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D" title="子元素相对定位"></a>子元素相对定位</h3><p>父元素设置了高度，而且父元素里面只有一个子元素，可使用子元素相对定位。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>.parentElement {<br> height: xxpx;<br>}  </p><p>.childElement {<br> position: relative;<br> top: 50%;<br> transform: translateY(-50%);<br>}  </p><h3 id="CSS3-flex"><a href="#CSS3-flex" class="headerlink" title="CSS3 flex"></a><a href="#CSS3-flex" title="CSS3 flex"></a>CSS3 flex</h3><p>如果不考虑低版本浏览器兼容性，用CSS3的flex布局就非常简单咯。</p><p>1<br>2<br>3<br>4  </p><p>.parentElement {<br> display: flex;<br> align-items: center;<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
            <tag> 垂直居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ES6新特性实现数组去重</title>
      <link href="2018/01/17/shi-yong-es6-xin-te-xing-shi-xian-shu-zu-qu-chong/"/>
      <url>2018/01/17/shi-yong-es6-xin-te-xing-shi-xian-shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组去重，对于前端开发者来说家常便饭的事，更是初学者必须掌握的知识，面试经常会考。</p><p>数组去重相关的方法，网上已有很多，大多使用了ES6以前的方法，本文对于不作赘述。但随着各大浏览器对ES6的支持性越来越好，以及ES6新特性深入人心，更何况作为一名前端工程师，我们应该顺应时代潮流，推动JavaScript发展，所以，尽情地拥抱ES6吧。</p><p>本文讲解使用ES6新特性实现数组去重的一种新方法，代码及其简短又高效。</p><h4 id="JavaScript代码："><a href="#JavaScript代码：" class="headerlink" title="JavaScript代码："></a><a href="#JavaScript%E4%BB%A3%E7%A0%81%EF%BC%9A" title="JavaScript代码："></a>JavaScript代码：</h4><p>1<br>2<br>3<br>4  </p><p>/*<br>* @param arr 传入的参数：带有重复项的数组<br>* */<br>Array.from(new Set(arr));</p><!-- more --><p>数组去重，对于前端开发者来说家常便饭的事，更是初学者必须掌握的知识，面试经常会考。</p><p>数组去重相关的方法，网上已有很多，大多使用了ES6以前的方法，本文对于不作赘述。但随着各大浏览器对ES6的支持性越来越好，以及ES6新特性深入人心，更何况作为一名前端工程师，我们应该顺应时代潮流，推动JavaScript发展，所以，尽情地拥抱ES6吧。</p><p>本文讲解使用ES6新特性实现数组去重的一种新方法，代码及其简短又高效。</p><h4 id="JavaScript代码：-1"><a href="#JavaScript代码：-1" class="headerlink" title="JavaScript代码："></a><a href="#JavaScript%E4%BB%A3%E7%A0%81%EF%BC%9A" title="JavaScript代码："></a>JavaScript代码：</h4><p>1<br>2<br>3<br>4  </p><p>/*<br>* @param arr 传入的参数：带有重复项的数组<br>* */<br>Array.from(new Set(arr));  </p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A" title="例子："></a>例子：</h4><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>/*<br>* @param oldArr 带有重复项的旧数组<br>* @param newArr 去除重复项之后的新数组<br>* */<br>let oldArr = [1, 1, 1, 2, 3, 2, 4, 4, 4, 9, 9, 0, 0, NaN, NaN];<br>let newArr = Array.from(new Set(oldArr));<br>console.log(newArr);  // [1, 2, 3, 4, 9, 0, NaN]  </p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><a href="#%E5%88%86%E6%9E%90%EF%BC%9A" title="分析："></a>分析：</h4><h5 id="Set对象"><a href="#Set对象" class="headerlink" title="Set对象"></a><a href="#Set%E5%AF%B9%E8%B1%A1" title="Set对象"></a>Set对象</h5><p>Set对象允许存储任何类型的唯一值，无论是原始值或者是对象引用。它可以是任何类型的单个值的集合。Set中的元素只会出现一次，即Set中的元素是唯一的。<br><code>语法：new Set([iterable]);</code><br>参数：iterable，如果传递一个可迭代对象(包括 Array，Map，Set，String，TypedArray，arguments 对象等等)，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的Set为空。</p><h5 id="Set对象例子"><a href="#Set对象例子" class="headerlink" title="Set对象例子"></a><a href="#Set%E5%AF%B9%E8%B1%A1%E4%BE%8B%E5%AD%90" title="Set对象例子"></a>Set对象例子</h5><p>1<br>2<br>3  </p><p>let testArr = [0, 1, 1, 2, 3, 3, 3, 3, 4, NaN, NaN, undefined, undefined];<br>let setTestArr = new Set(testArr);<br>console.log(setTestArr);  // Set(6) {1, 2, 3, 4, NaN, undefined}  </p><p><img src="http://www.www.www/" alt="Set对象例子"></p><h5 id="from对象"><a href="#from对象" class="headerlink" title="from对象"></a><a href="#from%E5%AF%B9%E8%B1%A1" title="from对象"></a>from对象</h5><p>Array.from()方法从一个类似数组或可迭代的对象(包括 Array，Map，Set，String，TypedArray，arguments 对象等等) 中创建一个新的数组实例。</p><h5 id="from对象例子"><a href="#from对象例子" class="headerlink" title="from对象例子"></a><a href="#from%E5%AF%B9%E8%B1%A1%E4%BE%8B%E5%AD%90" title="from对象例子"></a>from对象例子</h5><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>let testArr = [0, 1, 1, 2, 3, 3, 3, 3, 4, NaN, NaN, undefined, undefined];<br>let setTestArr = new Set(testArr);<br>console.log(setTestArr);  // {1, 2, 3, 4, NaN, undefined}  </p><p>let newArr = Array.from(setTestArr);<br>console.log(newArr);  // [1, 2, 3, 4, NaN, undefined]  </p><p><img src="http://www.www.www/" alt="from对象例子"></p><p><strong>使用ES6实现数组去重，就是如此简单，快去试试吧~</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 数组去重 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gulp搭建前端自动化工作流环境（简易版）</title>
      <link href="2017/11/30/shi-yong-gulp-da-jian-qian-duan-zi-dong-hua-gong-zuo-liu-huan-jing-jian-yi-ban/"/>
      <url>2017/11/30/shi-yong-gulp-da-jian-qian-duan-zi-dong-hua-gong-zuo-liu-huan-jing-jian-yi-ban/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文通过简单且实用的案例，讲解使用gulp搭建前端自动化工作流环境详细步骤，带领大家快速入门。</p></blockquote><!-- more --><blockquote><p>本文通过简单且实用的案例，讲解使用gulp搭建前端自动化工作流环境详细步骤，带领大家快速入门。</p></blockquote><h3 id="什么是gulp？"><a href="#什么是gulp？" class="headerlink" title="什么是gulp？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFgulp%EF%BC%9F" title="什么是gulp？"></a>什么是gulp？</h3><p>来自官网的简介：Automate and enhance your workflow. gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something.</p><p>大致意思是讲gulp是一款自动化构建工具，可用于增强你的开发工作流程，提高工作效率！前端界的友友们，这个工具可不要错过了哟~</p><p>了解更多信息，请前往： <a href="https://gulpjs.com/">gulp官网</a> 、 <a href="http://www.gulpjs.com.cn/">gulp中文网</a></p><h3 id="gulp优点"><a href="#gulp优点" class="headerlink" title="gulp优点"></a><a href="#gulp%E4%BC%98%E7%82%B9" title="gulp优点"></a>gulp优点</h3><ul><li><strong>易于使用</strong> 通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理。</li><li><strong>构建快速</strong> 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。</li><li><strong>插件高质</strong> gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。</li><li><strong>易于学习</strong> 通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="准备工作"></a>准备工作</h3><p><strong>gulp依赖Node.js，参考本教程的朋友们，请先在本地环境安装好Node.js，并确认Node.js、npm可正常使用。</strong></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><a href="#%E6%AD%A5%E9%AA%A4" title="步骤"></a>步骤</h3><h4 id="第一步-新建项目根文件夹-例：gulp-demo-，并在项目根目录下使用npm安装必要的包"><a href="#第一步-新建项目根文件夹-例：gulp-demo-，并在项目根目录下使用npm安装必要的包" class="headerlink" title="第一步 新建项目根文件夹(例：gulp-demo)，并在项目根目录下使用npm安装必要的包"></a><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A0%B9%E6%96%87%E4%BB%B6%E5%A4%B9-%E4%BE%8B%EF%BC%9Agulp-demo-%EF%BC%8C%E5%B9%B6%E5%9C%A8%E9%A1%B9%E7%9B%AE%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85" title="第一步 新建项目根文件夹(例：gulp-demo)，并在项目根目录下使用npm安装必要的包"></a>第一步 新建项目根文件夹(例：gulp-demo)，并在项目根目录下使用npm安装必要的包</h4><p>1  </p><p>$ npm install gulp gulp-less gulp-concat gulp-cssnano gulp-uglify gulp-htmlmin browser-sync –save-dev  </p><p>本案例使用的gulp插件介绍：</p><ul><li><strong>gulp-less</strong> 将less编译成css</li><li><strong>gulp-concat</strong> 将多个JavaScript合并</li><li><strong>gulp-cssnano</strong> css压缩</li><li><strong>gulp-uglify</strong> JavaScript压缩并混淆</li><li><strong>gulp-htmlmin</strong> html压缩</li><li><strong>browser-sync</strong> 多浏览器同步操作</li></ul><h4 id="第二步-在项目根文件夹-例：gulp-demo-下创建相关的文件结构"><a href="#第二步-在项目根文件夹-例：gulp-demo-下创建相关的文件结构" class="headerlink" title="第二步 在项目根文件夹(例：gulp-demo)下创建相关的文件结构"></a><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E6%A0%B9%E6%96%87%E4%BB%B6%E5%A4%B9-%E4%BE%8B%EF%BC%9Agulp-demo-%E4%B8%8B%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" title="第二步 在项目根文件夹(例：gulp-demo)下创建相关的文件结构"></a>第二步 在项目根文件夹(例：gulp-demo)下创建相关的文件结构</h4><h5 id="src-gulp编译之前的源文件"><a href="#src-gulp编译之前的源文件" class="headerlink" title="src [gulp编译之前的源文件]"></a><a href="#src-gulp%E7%BC%96%E8%AF%91%E4%B9%8B%E5%89%8D%E7%9A%84%E6%BA%90%E6%96%87%E4%BB%B6" title="src [gulp编译之前的源文件]"></a>src [gulp编译之前的源文件]</h5><ul><li><strong>css</strong> 我们在此处编写css文件</li><li><strong>img</strong> 我们在此处放置图片文件</li><li><strong>js</strong> 我们在此处编写css文件</li><li><strong>index1.html</strong></li><li><strong>index2.html</strong></li><li><strong>…….</strong></li></ul><h5 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a><a href="#node-modules" title="node_modules"></a>node_modules</h5><p>通过npm安装的包及其依赖包的库，自动生成文件夹。</p><h5 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a><a href="#gulpfile-js" title="gulpfile.js"></a>gulpfile.js</h5><p>gulp的入口文件，我们在此处编写相关任务代码。</p><h5 id="dist-gulp编译之后的文件，即我们最终要得到文件"><a href="#dist-gulp编译之后的文件，即我们最终要得到文件" class="headerlink" title="dist [gulp编译之后的文件，即我们最终要得到文件]"></a><a href="#dist-gulp%E7%BC%96%E8%AF%91%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8D%B3%E6%88%91%E4%BB%AC%E6%9C%80%E7%BB%88%E8%A6%81%E5%BE%97%E5%88%B0%E6%96%87%E4%BB%B6" title="dist [gulp编译之后的文件，即我们最终要得到文件]"></a>dist [gulp编译之后的文件，即我们最终要得到文件]</h5><ul><li><strong>css</strong></li><li><strong>img</strong></li><li><strong>js</strong></li><li><strong>index.html</strong></li></ul><h5 id="项目目录结构图示"><a href="#项目目录结构图示" class="headerlink" title="项目目录结构图示"></a><a href="#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA" title="项目目录结构图示"></a>项目目录结构图示</h5><p><img src="http://ojzaff7fe.bkt.clouddn.com/gulp%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="项目目录结构图示"></p><h4 id="第三步-在gulpfile-js文件里编写具体的任务代码"><a href="#第三步-在gulpfile-js文件里编写具体的任务代码" class="headerlink" title="第三步 在gulpfile.js文件里编写具体的任务代码"></a><a href="#%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%9C%A8gulpfile-js%E6%96%87%E4%BB%B6%E9%87%8C%E7%BC%96%E5%86%99%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81" title="第三步 在gulpfile.js文件里编写具体的任务代码"></a>第三步 在gulpfile.js文件里编写具体的任务代码</h4><h5 id="载入所需要的模块"><a href="#载入所需要的模块" class="headerlink" title="载入所需要的模块"></a><a href="#%E8%BD%BD%E5%85%A5%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%A8%A1%E5%9D%97" title="载入所需要的模块"></a>载入所需要的模块</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>‘use strict’;   // 启用JavaScript严格模式<br>var gulp = require(‘gulp’);<br>var less = require(‘gulp-less’);<br>var cssnano = require(‘gulp-cssnano’);<br>var concat = require(‘gulp-concat’);<br>var uglify = require(‘gulp-uglify’);<br>var htmlmin = require(‘gulp-htmlmin’);<br>var browserSync = require(‘browser-sync’);  </p><h5 id="less编译、压缩"><a href="#less编译、压缩" class="headerlink" title="less编译、压缩"></a><a href="#less%E7%BC%96%E8%AF%91%E3%80%81%E5%8E%8B%E7%BC%A9" title="less编译、压缩"></a>less编译、压缩</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>// 定义LESS编译、压缩的任务：css<br>gulp.task(‘css’, function () {<br> gulp.src([‘src/css/*.less’, ‘!src/css/_*.less’])<br> .pipe(less())<br> .pipe(cssnano())<br> .pipe(gulp.dest(‘dist/css’))<br> .pipe(browserSync.reload({<br> stream: true<br> }));<br>});  </p><h5 id="JavaScript合并、压缩、混淆"><a href="#JavaScript合并、压缩、混淆" class="headerlink" title="JavaScript合并、压缩、混淆"></a><a href="#JavaScript%E5%90%88%E5%B9%B6%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E6%B7%B7%E6%B7%86" title="JavaScript合并、压缩、混淆"></a>JavaScript合并、压缩、混淆</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11  </p><p>// 定义多个JavaScript文件合并、压缩混淆的任务：js<br>gulp.task(‘js’, function () {<br> gulp.src(‘src/js/*.js’)<br> .pipe(concat(‘index.js’)) // JS合并之后，文件命名为index.js<br> .pipe(uglify())  // JS压缩混淆<br> .pipe(gulp.dest(‘dist/js’))<br> .pipe(browserSync.reload({<br> stream: true<br> }));  </p><p>});  </p><h5 id="将src文件夹下img图片复制到dist文件夹下img"><a href="#将src文件夹下img图片复制到dist文件夹下img" class="headerlink" title="将src文件夹下img图片复制到dist文件夹下img"></a><a href="#%E5%B0%86src%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8Bimg%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6%E5%88%B0dist%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8Bimg" title="将src文件夹下img图片复制到dist文件夹下img"></a>将src文件夹下img图片复制到dist文件夹下img</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>// 定义image复制的任务：img<br>gulp.task(‘img’, function () {<br> gulp.src(‘src/img/*.*‘)<br> .pipe(gulp.dest(‘dist/img’))<br> .pipe(browserSync.reload({<br> stream: true<br> }));  </p><p>});  </p><h5 id="html代码压缩"><a href="#html代码压缩" class="headerlink" title="html代码压缩"></a><a href="#html%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9" title="html代码压缩"></a>html代码压缩</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>// 定义HTML压缩的任务：html<br>gulp.task(‘html’, function () {<br> gulp.src(‘src/*.html’)<br> .pipe(htmlmin({collapseWhitespace: true}))<br> .pipe(gulp.dest(‘dist’))<br> .pipe(browserSync.reload({<br> stream: true<br> }));<br>});  </p><h5 id="多浏览器同步操作，开启gulp监视文件变动"><a href="#多浏览器同步操作，开启gulp监视文件变动" class="headerlink" title="多浏览器同步操作，开启gulp监视文件变动"></a><a href="#%E5%A4%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%BC%80%E5%90%AFgulp%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E5%8F%98%E5%8A%A8" title="多浏览器同步操作，开启gulp监视文件变动"></a>多浏览器同步操作，开启gulp监视文件变动</h5><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16  </p><p>// 定义浏览器同步操作服务的任务：browserSync<br>gulp.task(‘browserSync’, function () {<br> browserSync({<br> server: {<br> baseDir: [‘dist’]<br> }  </p><p> }, function (err, bs) {<br> console.log(bs.options.getIn([“urls”, “local”]));<br> });<br> // 开启gulp监视<br> gulp.watch(‘src/css/*.less’, [‘css’]);  // less文件改动时，执行css任务<br> gulp.watch(‘src/js/*.js’, [‘js’]);  // js文件改动时，执行js任务<br> gulp.watch(‘src/img/*.*‘, [‘img’]);  // image文件改动时，执行img任务<br> gulp.watch(‘src/*.html’, [‘html’]);  // html文件改动时，执行html任务<br>});  </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><a href="#%E4%BD%BF%E7%94%A8" title="使用"></a>使用</h3><ul><li>1 <code>$ gulp css</code> LESS 编译 压缩 合并</li><li>2 <code>$ gulp js</code> JavaScript 合并 压缩 混淆</li><li>3 <code>$ gulp img</code> image 复制</li><li>4 <code>$ gulp html</code> HTML 压缩</li><li>5 <code>$ gulp browserSync</code> 多浏览器同步操作，gulp监视JS/CSS/HTML文件改变</li></ul><p>到此，基于gulp的前端自动化工作流环境搭建完成，以下使用视频教程。<br><img src="http://ojzaff7fe.bkt.clouddn.com/gulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.gif" alt="使用视频教程"></p><p><a href="https://github.com/itPoet/gulp">点击此处，下载本案例源代码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Gulp </tag>
            
            <tag> 前端自动化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
